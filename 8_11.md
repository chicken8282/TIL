# 8/11

# 문자열

## 연산

**문자열 역순**
- 문자열을 역순으로 재정의
```python
s = 'Reverse this strings'
s = s[::-1]
```
- 리스트로 변환 후 다시 문자열로 변환
```python
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)
```

**회문**
- "기러기", "토마토", "스위스"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
- 문자열 길이의 반만 비교하면 된다.
```
is_palindrome(txt):
  for i : 0 -> len(txt)/2 - 1
      if txt[i] != txt[len(txt) - 1 - i]
          return False
  return True
```

**문자열 비교**
- == 연산자와 is 연산자
- ==는 값(value)이 같은지를 비교한다.
- is는 객체의 정체성(identity), 즉 같은 객체(메모리 주소)인지 비교한다.
- == 연산자는 내부적으로 특수 메서드 __eq__()를 호출한다.

```python
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2] + 'c'

print(s1 == s2) # True
print(s1 is s2) # True
print(s4 == s5) # True
print(s4 is s5) # False

a = [1, 2, 3]
b = [1, 2, 3]

print(a == b) # True (값이 같음)
print(a is b) # False (다른 객체임)
```

C와 java에서의 문자열 비교

C
- strcmp()함수를 사용해 문자열의 내용을 비교한다.

Java
- == 연산자는 객체의 주소(참조)를 비교한다. (Python의 is 연산자 역할)
- equlas() 메소드는 객체의 내용을 비교한다. (Python의 == 역할)

사전 순서 비교

비교 연산자 < 사용
- 유니코드를 비교한다.

```python
def my_strcmp(s1, s2):
  if s1 < s2:
    return -1 # s1이 s2보다 사전 순서상 앞서는 경우
  elif s1 > s2:
    return 1 # s1이 s2보다 사전 순서당 나중인 경우
  else:
    return 0 # s1과 s2 문자열의 내용이 같은 경우
```

문자열을 숫자를 숫자로 변환
```python
a = int('123')
b = float('3.14')
c = int('A0', 16) # 문자열 'A0'를 16진법으로 해석해서 변환
```
숫자를 문자열로 변환
```python
a = str(123)
b= str(3.14)
```

# 패턴 매칭

## 고지식한 패턴 검색

고지식한 알고리즘 (Brute Force)
  - 단순한 방법
  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식

```python
def brute_force(p, t): # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
  i = 0 # t의 인덱스
  j = 0 # p의 인덱스
  M = len(p)
  N = len(t)
  while j < M and i < N:
    if t[i] != p[j]: # 다른 글자인 경우
      i = i - j
      j = -1
    i = i + 1
    j = j + 1
  if j == M: return i - M # 검색 성공
  else: return -1 # 검색 실패
```

시간 복잡도
- 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
- 길이가 10,000인 문자열에서 길이 80인 패턴을 찾는 경우
- 최악의 경우 약 10,000 * 80 = 800,000 번의 비교가 필요하다.

## KMP 알고리즘
- 연구자인 Knuth, Morris, Pratt 세 사람의 이름에서 유래
- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
  - 불일치가 발생할 글자의 앞 부분에 어떤 문자가 있는지를 미리 알고 있게 된다.
  - 조건에 따라, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않을 수 있다.
  - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 전처리가 필요하다.

시간 복잡도
- 패턴의 길이가 M일 때 전처리에 걸리는 시간은 O(M)이다.
- 텍스트의 길이가 N일 때 검색은 최악의 경우 O(N) 이다.
- 결과적으로 O(M+N)이 된다.
- 만약 M이 고정된 값으로 매우 짧다면 평균적으로 O(N)이 된다.

아이디어
- 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황
  - 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.

LPS(Longest Prefix which is also Suffix) 배열
- 접두사이자 접미사인 문자열의 최대 길이
- 일치하지 않을 때 비교할 인덱스
- 구현에 따라 next, pi 배열로도 불림

## 보이어 무어(Boyer-Moore) 알고리즘
- 상용 소프트웨어에서 채택하고 있는 알고리즘
- 실제 검색에서 매우 빠른 성능
  - 패턴 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼이 된다.

불일치 문자 휴리스틱(Bad-Character Heuristic)
- 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
  - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프한다.