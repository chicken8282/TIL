# 8/20

# 큐(Queue)

먼저 들어온 데이터가 먼저 나가는 선형 자료구조

## 큐의 구조
가장 먼저 넣은 자료가 가장 먼저 나오는 것

![alt text](<images/08_20/스크린샷 2025-08-20 085404.png>)

**큐의 기본 연산**
- 삽입: enqueue
- 삭제: dequeue

![alt text](<images/08_20/스크린샷 2025-08-20 085442.png>)

**큐의 연산 과정**

![alt text](<images/08_20/스크린샷 2025-08-20 085525.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 090030.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 090042.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 090059.png>)

# 선형 큐(Linear Queue)
데이터를 일렬로 저장하며, 앞에서 꺼내고 뒤에 넣는 기본 큐 구조

구현
- 배열이나 연결형 리스트로 구현할 수 있다.
- 큐의 크기는 배열의 크기와 같다.
- front: 가장 최근에 삭제된 원소의 인덱스
- rear: 마지막으로 저장된 원소의 인덱스

상태표현
- 초기 상태: front = rear = -1
- 공백 상태: fornt == rear
- 포화 상태: rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)

## 선형 큐의 구현
1. 초기 공백 큐 생성: create_queue()
  - 크기 n인 1차원 배열 생성
  - front와 rear를 -1로 초기화
```python
# create_queue()
q = [0] * n
front = -1
rear = -1
```
2. 삽입: enqueue(item)
  - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
  1. rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 지정
  2. 그 인덱스에 해당하는 배열원소 Q[rear]에 item을 저장
```
enqueue(item):
      global rear
      if is_full(): print("Queue_Full")
      else:
        rear <- rear + 1;
        q[rear] <- item;
```
3. 삭제: dequeue()
  - 가장 앞에 있는 원소를 삭제하기 위해
  1. front 값을 하나 증가시켜 큐에 남아있는 첫 번째 원소 이동
  2. 새로운 첫 번째 원소를 리턴 함으로써 삭제와 동일한 가능함
```
dequeue():
        if(is.empty()) then queue_empty();
        else
              front <- front + 1;
              return Q[front];
```
4. 공백상태 및 포화상태 검사: is_empty(), is_full()
  - 공백상태: front == rear
  - 포화상태: rear == n-1(n: 배열의 크기, n-1: 배열의 마지막 인덱스)
```
is_empty():
        return front == rear
is_full():
        return rear == len(q) -1
```
5. 검색: qpeek()
  - 가장 앞에 있는 원소를 검색하여 반환하는 연산
  - 현재 front의 한자리 뒤(front + 1)에 있는 원소, 즉 큐의 첫번째에 있는 원소를 반환
```python
def qpeek():
        if is_empty(): print("Queue_Empty")
        else: return q[front + 1]
```

# 원형 큐(Circular Queue)
선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

## 원형 큐의 구조
- 초기 공백 상태
    - `front = rear = 0`
- Index의 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨다.
    - 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 한다.
    - 이를 위해 나머지 연산자 mod를 사용한다.
- front 변수
    - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둔다.

**선형 큐와 원형 큐 비교**

![alt text](<images/08_20/스크린샷 2025-08-20 092045.png>)

**원형 큐 연산 과정**

![alt text](<images/08_20/스크린샷 2025-08-20 092129.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 092143.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 092158.png>)

원형 큐의 구현
1. 초기 공백 큐 생성
    - 크기 n인 1차원 배열 생성
    - front와 rear를 0으로 초기화
```python
cq = [0] * n
front = rear = 0
```
2. 삽입: enqueue(item)
    - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
    1. rear 값을 조정하여 새로운 원소를 삽입할 자리를 지정
        - rear <- (rear + 1) mod n;
    2. 그 인덱스에 해당하는 배열원소 cQ[rear]에 item을 저장
```python
def enqueue(item):
    global rear
    if is_full():
        print("Queue_Full")
    else:
        rear = (rear + 1) % len(cq)
        cq[rear] = item
```
3. 삭제: dequeue()
    - 가장 앞에 있는 원소를 삭제하기 위해
    1. front 값을 조정하여 삭제할 자리를 지정
    2. 새로운 front 원소를 리턴 함으로써 삭제와 동일한 기능함
```python
def dequeue():
    global front
    if is_empty():
        print("Queue_Empty")
    else:
        front = (front + 1) % len(cq)
        return cq[front]
```
4. 공백상태 및 포화상태 검사: is_empty(),is_full()
    - 공백상태: front == rear
    - 포화상태: 삽입할 rear의 다음 위치 == 현재 front
        - (rear + 1) mod n == front
```python
def is_empty():
    return front == rear
def is_full():
    return (rear + 1) % len(cq) == front
```

# 연결 큐(Linked Queue)
연결 리스트를 이용해 구현한 큐

## 연결 큐의 구조
단순 연결 리스트(Linked List)를 이용한 큐
- 큐의 원소: 단순 연결 리스트의 노드
- 큐의 원소 순서: 노드의 연결 순서. 링크로 연결되어 있음
- front: 첫 번째 노드를 가리키는 링크
- end: 마지막 노드를 가리키는 링크
상태 표현
- 초기 상태: front = rear = null
- 공백 상태: front == rear = null

![alt text](<images/08_20/스크린샷 2025-08-20 095346.png>)

**연결 큐의 연산 과정**

![alt text](<images/08_20/스크린샷 2025-08-20 095757.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 095807.png>)
![alt text](<images/08_20/스크린샷 2025-08-20 095819.png>)

**덱(deque)**
- 컨테이너 자료형 중 하나로 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너
    - 연결 리스트를 직접 만들지 않아도 된다.
**deque의 연산**
- append(x): 오른쪽에 x추가
- popleft(): 왼쪽에서 요소를 제거하고 반환. 요소가 없으면 IndexError
```python
from collections import deque

q = deque()
q.append(1) # enqueue()
t = q.popleft() # dequeue()
```

**연결 큐의 구현 코드**
```python
class Node:
    def __init__(self, item, n = None):
        self.item = item
        self.next = n
def enqueue(item): # 연결 큐의 삽입 연산
    global front, rear
    newNode = Node(item) # 새로운 노드 생성
    if front == None: # 큐가 비어있다면
        front = new Node
    else:
        rear.next = newNode
    rear = newNode

def is_empty():
    return front == None

def dequeue(): # 연결 큐의 삭제 연산
    global front, rear
    if is_empty():
        print("Queue_Empty")
        return None
    item = front.item
    front = front.next
    if front == None:
        rear = None
    return item

def qpeek():
    return front.item

def print_q():
    f = front
    s = ""
    while f:
        s += f.item + " "
        f = f.next
    return s

front = None
rear = None
```

# 우선순위 큐(Priority Queue)
우선순위를 가진 항목들을 저장하는 큐

**우선순위 큐의 연산**
- 삽입: enqueue
- 삭제: dequeue

![alt text](<images/08_20/스크린샷 2025-08-20 103032.png>)

**우선순위 큐의 구현**

**배열을 이용한 우선순위 큐**
- 배열을 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치를 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 된다.

문제점
- 배열을 사용하므로, 삽입이나 삭제 연산이 얼어날 때 원소의 재배치가 발생한다.
- 이에 소요되는 시간이나 메모리 낭비가 크다.

# 버퍼(Buffer)
데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역, 버퍼를 채우는 것을 버퍼링이라고 한다.

**버퍼의 자료 구조**
- 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
- 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다.

**버퍼의 예시: 키보드 버퍼**

![alt text](<images/08_20/스크린샷 2025-08-20 104908.png>)