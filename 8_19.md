# 8/19

# 백트래킹

## 부분집합
어떤 집합의 공집합과 자기자신을 포함한 모든 부분

백트래킹 기법으로 powerset 만들기
- 앞으로 설명한 일반적인 백트래킹 접근 방법을 이용
- N개의 원소가 들어있는 집합의 2^n개의 부분집합을
  - True또는 False값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
- 여기서 배열의 i번째 항복은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값
![alt text](<images/스크린샷 2025-08-19 140433.png>)

각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법
![alt text](<images/스크린샷 2025-08-19 140522.png>)

[1, 2, 3]의 부분집합 표현
![alt text](<images/스크린샷 2025-08-19 140837.png>)

powerset을 구하는 백트래킹 알고리즘
```python
def backtrack(a, k, n): # a: 주어진 배열, k: 결정할 원소, n: 원소 개수
    c = [0] * MAXCANDIDATES

    if k == n:
        process_solution(a, k) # 답이면 원하는 작업을 한다
    else: # ncandidates: 후보수, c: 후보군 저장
        ncandidates = construct_candidates(a, k, n, c) # 후보추천 함수
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k + 1, n)

# powerset을 구하는 백트래킹 알고리즘 2

def construct_candidates(a, k, n, c):
    c[0] = True
    c[1] = False
    return 2
def process_solution(a, k):
    for i in range(k):
        if a[i]:
            print(num[i], end = ' ')
    print()

MAXCANDIDATES = 2
NMAX = 4
a = [0] * NMAX
num = [1, 2, 3, 4]
backtrack(a, 0, 3)
```
## 순열1

백트래킹과 순열
![alt text](<images/스크린샷 2025-08-19 142750.png>)

백트래킹을 이용하여 {1, 2, 3, ..., NMAX}에 대한 순열 구하기
```python
def backtrack(a, k, n): # a: 주어진 배열, k: 결정할 원소, n: 원소 개수
    c = [0] * MAXCANDIDATES

    if k == n:
        for i in range(0, k):
            print(a[i], end = " ")
        print()
    else: # ncandidates: 후보수, c: 후보군 저장
        ncandidates = construct_candidates(a, k, n, c) # 후보추천 함수
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k + 1, n)
    
def construct_candidates(a, k, n, c):
    in_perm = [False] * (NMAX + 1)

    for i in range(k):
        in_perm[a[i]] = True

    ncandidates = 0
    for i in range(1, NMAX + 1):
        if in_perm[i] = False:
            c[ncandidates] = i
            ncandidates += 1
    return ncandidates

MAXCANDIDATES = 3
NMAX = 3
a = [0] * NMAX
backtrack(a, 0, 3)
```

## 가지치기

부분집합의 합
- 집합 [1, 2, 3]의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현
![alt text](<images/스크린샷 2025-08-19 143838.png>)

- i 원소의 포함 여부를 결정하면 i까지의 부분집합의 합 Si를 결정할 수 있음
- Si - 1이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음
![alt text](<images/스크린샷 2025-08-19 144749.png>)

- A[i] 원소를 부분집합의 원소로 고려하는 재귀 함수 (A는 서로 다른 자연수의 집합)
![alt text](<images/스크린샷 2025-08-19 150231.png>)

- 추가 고려 사항
![alt text](<images/스크린샷 2025-08-19 152249.png>)


## 순열 2
A[1, 2, 3]의 모든 원소를 사용한 순열
- 3개의 칸에 넣을 수 있는 수를 나열
- 123, 132, 213, 231, 312, 321
- 총 6가지의 경우
![alt text](<images/스크린샷 2025-08-19 154351.png>)

**자리교환으로 순열 생성**

![alt text](<images/스크린샷 2025-08-19 154132.png>)

![alt text](<images/스크린샷 2025-08-19 154139.png>)

## 분할정복

설계 전략
- 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복(Conquer): 나눈 작은 문제를 각각 해결한다.
- 통합(Combine): (필요하다면) 해결된 해답을 모은다.

거듭 제곱(Exponentialtion)
- O(n)
![alt text](<images/스크린샷 2025-08-19 154659.png>)

`0 ** 0 = 1 으로 취급`