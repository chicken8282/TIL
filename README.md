# 개발자로 성장하기

## 개발자로 성장하기

1. 순서가
   1. 있는
2. 리스트

- 순서가
  - 없는
- 리스트

```python
print("hello")
```

어떤 텍스트 안에
`print("hello")`
코드를 포함하고 싶다.

[클릭하면 구글로 이동](https://www.google.com/)

![이미지](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSz431yZ4IjKOx_ZtPgFKZr3EHl5Ko8V2LJFi9U2klVAB8rnG5c9x4ddmpTsDnUojXK4KK8Y5i21nR-2THUrZFQSaO2oDAjYm08FKxXns2p)

![이미지](images.webp)cd

**굵게**

_기울임_

~~취소~~

---

본문2

| Syntax    | Description |
| --------- | ----------- |
| Header    | Title       |
| Paragraph | Text        |

:joy:
:boom:
:

`touch`: 파일 생성
`mkdir`: 새 디렉토리 생성
`ls`: 현재 작업 중인 디렉토리 내부의 폴더/파일 목록을 출력
`cd`: 현재 작업 중인 디렉토리를 변경 (위치 변경)
`start`: 폴더/파일을 열기 (Mac에서는 open을 사용)
`rm`: 파일 삭제 (디렉토리 삭제는 -r 옵션을 추가 사용)
`pwd`: 현재 작업 중인 폴더(디렉토리)의 절대 경로를 출력

`Working Directory`: 실제 작업 중인 파일들이 위치하는 영역

`Staging Area`: Working Directory에서 변경된 파일 중, 다음 버전에 포함시킬 파일들을 선택적으로 추가하거나 제외할 수 있는 중간 준비 영역

`Repository`: 버전 이력과 파일들이 영구적으로 저장되는 영역, 모든 버전과 변경 이력이 기록됨

`commit`: 변경된 파일들을 저장하는 행위, 'snapshot' 이라고도 함

`git init`: 로컬 저장소 설정(초기화)
-> git의 버전 관리를 시작할 디렉토리에서 진행

`git add`: 변경사항이 있는 파일을 staging area에 추가

`git commit`: staging area에 있는 파일들을 저장소에 기록
-> 해당 시점의 버전을 생성하고 변경 이력을 남기는 것

`git rm -cashed test.txt` -> staging area에서 다시 working directory로 이동
`git commit -m sample.txt` -> staging area에서 repository로 커밋

# git 로컬 저장소 내에 또다른 git 로컬 저장소 만들지 말 것

`git commit --amend`

1. commit 메시지 수정 -> 아무거나 누른 뒤 수정 후 esc -> :wq(write queue) 입력
2. commit 전체 수정

`git remote add origin remote_repo_url`: 원격 저장소 추가

`git push origin(원격저장소 이름) master(branch 이름)` : 로컬저장소 -> 원격저장소로 커밋이 올라가는 것

`git `pull` origin master`: 원격저장소의 변경사항만을 받아옴 (업데이트)

`git clone remote_repo_rul` : 원격 저장소 전체를 복제 (다운로드)\
**clone으로 받은 프로젝트는 이미 git init이 되어 있음**

`git remote -v`: 현재 로컬 저장소에 등록된 원격 저장소 목록 보기

`git remote rm 원격_저장소_이름`: 현재 로컬 저장소에 등록된 원격 저장소 삭제

`git revert <commit id>`: commit을 없었던 일로 만드는 작업

- 프로젝트 기록에서 commit을 없었던 일로 처리 후 그 결과를 새로운 commit으로 추가함

- 변경 사항을 안전하게 실행 취소할 수 있도록 도와주는 순방향 실행 취소 작업

- commit 기록에서 commit을 삭제하거나 분리하는 대신, 지정된 변경 사항을 반전시키는 새commit을 생성

- git에서 기록이 손실되는 것을 방지하여 기록의 무결성과 협업의 신뢰성을 높임

`git reset [옵션] <commit id>`: 특정 commit으로 되돌아 갔을 때, 되돌아간 commit 이후의 commit은 모두 삭제

# 옵션

- `--soft`
  - 삭제된 commit의 기록을 staging area에 남김
- `--mixed`
  - 삭제된 commit의 기록을 working directory에 남김 (기본 옵션 값)
- `--hard`
  - 삭제된 commit의 기록을 남기지 않음

`git reflog`

- HEAD가 이전에 가리켰던 모든 commit을 보여줌
- reset의 --hard 옵션을 통해 지워진 commit도 reflog로 조회하여 복구 가능

`git reset --hard<복구하고자 하는 commitID>`

`git restore`: Modified 상태의 파일 되돌리기

- 원래 파일로 덮어쓰는 원리이기 때문에 수정한 내용은 전부 사라짐
- **git restore를 통해 수정 취소 후에는 해당 내용을 복원할 수 없음**

`git rm --cached`: Staging Area에서 Working Directory로 되돌리기\
-> git 저장소에 "commit이 없는 경우"

`git restore --staged`: Staging Area에서 Working Directory로 되돌리기\
-> git 저장소에 "commit이 존재하는 경우"

---

# Interface

: 서로 다른 두 개의 시스템 (기기, 소프트웨어 등)이 정보를 교환할 때, 그 사이에 존재하는 접점

## 예시

- 키보드, 마우스, 모니터
- TV 리모컨
- 자동차 운전대, 페달
- 스마트폰 터치 스크린

## UI (User Interface)

: 사람이 소프트웨어에 접근하는 그랙픽적, 화면적 요소

- 실제로는 기계와 기계, 시스템과 시스템 사이에서도 수많은 '인터페이스'를 통해 정보를 주고받고 있음
- 여기서는 UI가 없을 뿐, 약속된 방식으로 데이터를 주고받음

---

# 클라이언트 (Client)

서비스를 요청하는 쪽

# 서버

요청을 받아서 처리하고, 결과를 응답해주는 쪽

## 예시

- 사용자가 브라우저로 특정 주소(URL)를 요청
  -> 서버가 해당 페이지, 데이터 등을 보내줌

# API (Application Programming Interface)

두 소프트웨어(또는 시스템)가 통신할 수 있게 하는 메커니즘\
-> '약속된 방식의 인터페이스'로, 특정 규칙에 따라 데이터를 요청하고 응답하는 규칙을 제공

## Application

특정 기능을 수행하는 모든 소프트웨어\
-> 웹,모바일,데스크톱 앱 등, 우리가 만든 서비스나 프로그램도 모두 앱의 일종

## API KEY

API에게 요청을 보내는 애플리케이션을 구별하기 위한 고유한 식별 문자열

### 과정

1. Client 날씨 API 사이트에서 회원 가입
2. 날씨 사이트서 Clinet에게 API KEY 발급
3. Client가 요청 시 발급 받은 API KEY를 요청마다 함께 보냄
4. 요청 받은 Server는 Key를 검사해 인증 혹은 인증 실패 여부를 결정하여 응답함

## 정리

- API는 클라이언트와 서버 이 둘 사이의 "눈에 보이지 않는 인터페이스" 역할

- API KEY는 이 통신을 더욱 안전하게 만들기 위한 핵심 수단

## 토큰

- GPT와 같은 인공지능 모델에서 텍스트 데이터를 처리하고 이해하는 기본 단위
- 토큰은 문장에서 단어로 생각할 수 있음
  - 각 토큰별로 고유한 숫자가 매겨져있음
  - 영어보다 한글 문장을 표현하는데 더 많은 토큰 소요됨
    - 한글은 다양한 조합형 문자로 인해 많은 토큰이 필요
- 최대 입력 토큰 제한: 각 LLM 모델마다 최대로 입력할 수 있는 토큰 수가 제한
- 토큰 수 확인: openAI Docs tokenizer 페이지 활용

## 파라미터

### 필수 파라미터

- model: GPT 모델 이름 (예: gpt-4o-mini)
- messages: 대화 메시지 기록

### 응답 다양성 제어

- temperature: 다음 토큰(단어) 예측의 다양성을 조정 (0~2)
  - 응답의 창의성과 다양성 조정
- top_p: 선택할 토큰의 확률 범위를 제한 (0~1)

  - 누적 확률 기반으로 응답의 범위 제한

  ***

# 7/21

### 변수

값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름\
**"객체를 가리키는 이름"**

### 변수할당

표현식이 만들어 낸 값에 이름을 붙이는 과정(연결)

### 할당문(Assignment Statement)

```python
degrees = 36.5
```

`degrees` : 변수 이름\
`=` : 할당 연산자 오른쪽\ 표현식의 평가 결과 값을 왼쪽 변수에 저장\
`36.5`: 표현식

### 변수명 규칙

- 영문 알파벳, 언더스코어(\_), 숫자로 구성
- 숫자로 시작할 수 없음
- 대소문자를 구분
- 파이썬의 내부 예약어로 사용할 수 없는 키워드가 있음

### 변수, 값, 메모리

- 고유한 ID(메모리 주소)
  - 제품의 바코드
- 타입(Type)
  - 제품의 종류 (예: '정수', '실수', '문자열' 등)
- 값 (Value)

  - 제품의 실제 내용물

- **값+타입+주소 정보를 묶은 것을 객체(Object)라고 부름**

### 재할당

- 변수는 특정 값을 '기억'하거나 '가리키는' 이름
- 재할당은 이 변수가 가리키는 대상을 새로운 값으로 변경하는 행위

# 타입(Tpye)

변수나 값이 가질 수 있는 데이터의 종류를 의미

## 구성 요소 2가지

- 값(피연산자): 1, 2, 3...
- 연산자: +,-,\*,/...
- 값은
  - 숫자일 수도
  - 글자일 수도
  - 소수일 수도
  - 덩어리일 수도

## 데이터 타입(Data Type)

값의 종류와 그 값으로 할 수 있는 '동작(연산)'을 결정하는 속성
**데이터 타입이 필요한 이유**

- 각 타입에 따라 가능한 기능과 연산이 다르기 때문

# 자료형

## 정수형

소수점이 없는 숫자를 표현 (양수, 0, 음수 포함)

### 지수 표현법

```python
student_count = 30
temperature = -5
balance = 0
```

## 실수형

소수점이 있는 더 정밀한 숫자를 표현

### 지수 표현법

- 아주 크거나 아주 작은 실수를 간결하게 표현하기 위해 사용하는 방식
- 'e' 또는 'E'를 사용

```python
big_number = 1.23e9
small_number = 3.14e-3
```

## sequence Types

여러 개의 값들을 순서대로 나열하여 저잘하는 자료형

### 대표 시퀀스 타입

- str, list, tuple, range
- 모든 칸에는 0번부터 시작하는 고유한 번호(인덱스)가 붙어있음

### 시퀀스 타입의 5가지 공통 특징

1. 순서(Order)

- 값들이 순서대로 저장 (정렬X)

2. 인덱싱(Indexing)

- 각 값에 고유 번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음

3. 슬라이싱(Slicing)

- 인덱스 범위를 조절해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용할 수 있음

4. 길이(Length)

- len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음

5. 반복(lteration)

- 반복문을 사용하여 각 값을 하나씩 순서대로 꺼내 사용할 수 있음

## 문자열(str)

문자들의 **순서**가 있는 **변경 불가능한** 시퀀스 자료형

- 작은 따옴표(') 또는 큰따옴표(")로 감싸서 표현

```python
print('Hello, World!')
print("Hello, World!")
```

- 따옴표 안에 다른 따옴표를 넣고 싶을 때는 서로 다른 종류의 따옴표를 사용

```python
print('문자열 안에 "큰따옴표"를 사용하려면 작은 따옴표로 묶는다.')
```

- 이스케이프 시퀀스(Escape Sequence)
  - 역슬래시(\)와 문자를 조합해 특별한 기능을 수행

```python
# 따옴표 앞에 \를 붙여 문자로 인식시킴
print('He\'s a boy.')
# \n 은 줄바꿈 (엔터)을 의미함
print('첫째 줄" \n 둘째 줄')
#여러 줄 문자열을 작성할 때 는 """ 또는 '''를 사용
multi_line_str = """
이것은
여러 줄로 이루어진
문자열입니다.
"""
```

### f-string

문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법

- 문자열 시작 전'f'접두어를 붙이고, 삽입할 부분(표현식)을 중괄호 {}로 감싸줌

```python
name = '홍길동'
age = 25

greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'

# 안녕하세요, 제 이름은 홍길동이고 나이는 25살입니다.
print(greeting)
```

### 슬라이싱

시작 인덱스와 끝 인덱스를 지정하여 해당 범위의 값을 포함하는 새로운 시퀀스를 생성

`my_sequence[start:stop:step]`

1. start: 슬라이싱을 시작할 인덱스 (포함됨)
2. stop: 슬라이싱을 끝낼 인덱스 (포함되지 않음)
3. step:몇 개씩 건너뛰며 값을 가져올지에 대한 간격

```python
my_str = 'hello'
#2번부터 4번 앞까지 잘라 냄
print(my_str[2:4]) # ll
#시작부터 3번 앞까지 잘라 냄
print(my_str[:3]) # hel
#3번부터 끝까지 잘라 냄
print(my_str[3:]) # lo
#처음부터 끝까지 2칸 간격으로 값을 가져옴
print(my_str[::2]) # hlo
# 방향을 바꿔 끝에서부터 잘라낼 수도 있음
print(my_str[::-1]) #olleh
```

### 문자열 바꾸기

- 기존 문자열의 일부와 새로운 값을 조합하여 **새로운 문자열을 만들어야 함**

## 코드에서 진법 표현하기

- 파이썬은 코드 내에서 다양한 진법의 숫자를 직접 표현할 수 있도록 특별한 접두사(prefix)를 제공

- 2진수: 0b
- 8진수: 0o
- 16진수: 0x

## 부동소수점 오차

- 발생 원인
  1. 컴퓨터는 2진법 사용
  - 컴퓨터는 모든 숫자를 0과 1로 이루어진 2진수로 변환하여 저장
  2. 무한 소수의 발생과 근사값 저장
  - 우리가 쓰는 10진수 소수 중 일부(예:0.1)는 2진수로 바꾸면 무한히 반복되는 무한 소수가 됨
  - 메모리는 유한하기 때문에, 컴퓨터는 이 무한 소수를 어쩔 수 없이 가장 가까운 근사값으로 잘라서 저장함

### 해결책: 정확한 계산이 필요할 때

- 대표적으로 decimal 모듈을 사용해 부동소수점 연산의 정확성을 보장하는 방법
- decimal은 실수를 2진수로 변환하지 않고, 10진수 자체로 정확하게 연산할 수 있게 해줌

# 문장 (Statement)

특정 동작을 지시하는, 실행 가능한 코드의 최소 단위

# Style Guide

코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들의 모음

- 변수명은 무엇을 위한 변수인지 직관적인 이름을 가져야 함
- 공백(spaces) 4칸을 사용하여 코드 블록을 들여쓰기
- 한 줄의 길이는 79자로 제한하며, 길어질 경우 줄 바꿈을 사용
- 문자와 밑줄(\_)을 사용하여 함수, 변수, 속성의 이름을 작성
- 함수 정의나 클래스 정의 등의 블록 사이에는 빈 줄을 추가
- 등등...

## Python tutor

파이썬 코드가 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구

# 7/22

# list
여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형
## 표현
- 대괄호 [] 안에 값들을 쉼표(,)로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는등 자유롭게 변경할 수 있음
```python
my_list_1 = []
my_list_2 = [1, 'a', 3 ,'b', 5]
my_list_3 = [1, 2, 3, ['Python', 'world', '!!!']]
```

## 리스트의 시퀀스 특징
- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

## 중첩 리스트
다른 리스트를 값으로 가진 리스트

### 접근하기
- 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음

1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
    - `my_list[4] -> ['hello', 'world', '!!!']`
2. 선택한 안쪽 리스트에 다시 한번 인덱스를 사용
    - `my_list[4][-1] -> '!!!'`

## 리스트의 가변성
여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형\
**-> 추가, 삭제, 변경 가능**

# tuple
여러 개의 값을 순서대로 저장하는 **변경 불가능한 시퀀스 자료형**

## 튜플 표현
- 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음
```python
my_tuple_1 = ()
my_tuple_2 = (1,)
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```
-  소괄호 없이도 만들 수 있다.
- 단일 요소 튜플을 만들 때 반드시 Trailing comma (후행 쉼표)를 사용해야 합니다.
## 시퀀스 특징
- 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음
## 튜플 변경 시도하기
- 한번 생성된 튜플을 그 내용을 절대 수정, 추가, 삭제할 수 없음

### 어디 쓰일까?
- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값 교환, 함수 다중 반환 값 등
```python
# 다중 할당
x, y = 10, 20
# 실제 내부 동작
(x, y) = (10, 20)

# 값 교환
x, y = 1, 2
x, y = y, x
# 실제 내부 동작
temp = (y, x)
x, y = temp
print(x, y) # 2 1
```

# range
- 연속된 정수 시퀀스를 생성하는, 변경 불가능한(immutable) 자료형
    - 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용하다.
    - 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용

## range 기본 구문
- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있다.\
`range(start, stop, step)`
## 매개변수별 특징
- range(stop)
    - 매개변수가 아니면 stop으로 인식
    - start는 0이, step은 1이 기본값으로 자동 설정
    - range(5) = 0, 1, 2, 3, 4
- range(start, stop)
    - 매개변수가 두 개면 start와 stop으로 인식
    - step은 1이 기본값으로 자동 설정
    - range(2, 5) -> 2, 3, 4
- range(start, stop, step)
    - 모든 매개변수를 직접 지정
    - range(2, 10, 2) -> 2, 4, 6, 8
    
```python
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_1)  # range(0, 5)
print(my_range_2)  # range(1, 10)
print(my_range_3)  # range(5, 0, -1)

# 리스트로 형 변환 시 데이터 확인 가능
print(list(my_range_1))  # [0, 1, 2, 3, 4]
print(list(my_range_2))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3))  # [5, 4, 3, 2, 1]
```
## 규칙
1. 값의 범위 규칙
- stop 값은 생성되는 시퀀스에 절대 포함되지 않음
- range(1, 5)는 1부터 5 '전'까지의 숫자를 의미하므로 1, 2, 3, 4가 생성

2. 증가/감소 값(step) 규칙
- steap 값은 숫자 시퀀스의 간격과 방향을 결정

    1. step이 양수일 때
        - 숫자가 start부터 stop을 향해 증가
    2. step이 음수일 때
    - 숫자가 start부터 stop을 향해 감소
    - 이 경우, start 값은 stop 값보다 반드시 커야 함

# dict
- **key - value 쌍**으로 이루어진 **순서와 중복**이 없는 **변경 가능**한 자료형

## 표현
- 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- Key(키)
    - 값을 식별하기 위한 고유한 '이름표'(중복불가)
- Value(값)
    - 키에 해당하는 실제 데이터
- 각 값에는 순서가 없음

```python
my_dict_1 = {}
my_dict_2 = {'key': 'value'}
my_dict_3 = {'apple': 12, 'list': [1, 2, 3]}

print(my_dict_1)  # {}
print(my_dict_2)  # {'key': 'value'}
print(my_dict_3)  # {'apple': 12, 'list': [1, 2, 3]}
```

- 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서는 출력 시 그대로 유지해주긴 함
- 하지만 여전히 딕셔너리의 핵심은 순서가 없는 자료형이라는 점과 key를 통한 접근이라는 점 기억하자

## 규칙
- key의 규칙
    - 고유해야 함
        - key는 중복될 수 없음
    - 변경 불가능한 자료형만 사용 가능
        - 가능: str, int, float, tuple
        - 불가능: list, dict

- value의 규칙
    - 어떤 자료형이든 자유롭게 사용할 수 있음

## 접근 방법
- key를 사용하여 해당 Value를 꺼내 올 수 있음
- key에 접근 시 대괄호 [] 사용

## 값 추가 및 변경
```python
# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```
# set
순서와 중복이 없는 변경 가능한 자료형

## 표현
- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능

```python
my_set_1 = set()
my_set_2 = {1, 2, 3}
my_set_3 = {1, 1, 1}

print(my_set_1)  # set()
print(my_set_2)  # {1, 2, 3}
print(my_set_3)  # {1}
```

## 핵심 특징
1. 중복을 허용하지 않음
    - 똑같은 값은 단 하나만 존재할 수 있음
2. 순서가 없음
    - 인덱싱(set[0])이나 슬라이싱(set[0:2])을 사용할 수 없음

## 집합 연산
- 세트는 수학의 '집합' 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적

```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```
# None
파이썬에서 '값이 없음'을 표현하는 특별한 데이터 타입

- 값이 '존재하지 않음' 또는 '아직 정해지지 않음' 이라는 상태를 나타내기 위해 사용됨

# Boolean
참(True)과 거짓(False)단 두 가지 값만 가지는 데이터 타입

- 비교 / 논리 연산의 평가 결과로 사용됨

# Collection
여러 개의 값을 하나로 묶어 관리하는 자료형들을 통치하는 말

- str, list, tuple, range, set, dict 데이터 타입이 모두 Colletion에 분류됨

## 불변 vs 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변'두 그룹으로 나뉨

# 형변환
한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 예를 들어, 문자열"100"을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 등 데이터의 '형태'를 필요에 따라 바꾸는 것

## 암시적 형변환
파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
- 암시적 형변환은 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙

### 예시
- 정수와 실수의 연산에서 정수가 실수로 변환됨
- Boolean과 Numertic Type에서만 가능

## 명시적 형변환
개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
- 명시적 형변환은 서로 다른 타입의 데이터를 '호환'되도록 맞추는 과정

# 연산자

## 산술 연산자
수학적 계산을 위해 사용되는 연산자

## 복합 연산자
연산과 할당이 함께 이뤄짐\
`+=` `-=` `*=` `/=` `//=` `%=` `**=` 등등

## 비교 연산자
두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환\
`<`, `<=`, `==`, `!=`, `is`, `is not` 등등

### == 연산자
- 값(데이터)이 같은지를 비교
- 동등성
- 1 == True의 경우 파이썬이 내부적으로 Truef를 1로 간주할 수 있으므로 True결과가 나옴

### is 연산자
- 객체 자체가 같은지를 비교
- 식별성
-  두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용

#### is 연산자는 언제 사용하는가?
- 주로 싱글턴 객체를 비교 할 때 사용함

#### 싱글턴 객체
- 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체
- 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
- 파이썬의 대표적인 싱글턴 객체: None, True, False

### 정리
- is는 주로 싱글턴 객체에 대한 비교 시 사용
- 값 비교에는 `==`을 사용하고, 객체 비교에는 `is`를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값) 을 판단해야 할 때 is를 쓰면 의도치 않은 결과가 나올 수 있으며, 이는 파이썬 내부적인 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문

## 논리 연산자
- 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용(and, or, not이 대표적)

### 단축 평가
논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

#### 단축 평가를 하는 이유
- 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함

## 멤버십 연산자
특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

`in`: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인\
`not in`: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인

## 시퀀스형 연산자
- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- `+`는 시퀀스를 연결하는 기능을, `*`는 시퀀스를 반복하는 기능을 함

# 후행 쉼표(Trailing Comma)
컬렉션의 마지막 요소 뒤에 붙는 쉼표

## 기본 규칙
- 각 요소를 별도의 줄에 작성
- 마지막 요소 뒤에 trailing comma 추가
- 닫는 괄호는 새로운 줄에 배치

# 7/23

# 함수
특정 작업을 수행하기 위한 **재사용 가능한 코드 묶음**

## 함수 호출(function call)
- 함수를 실행하기 위해 함수의 이름을 사용하여 해당 함수의 코드 블록을 실행하는 것

## 함수 구조
```python
def make_sum(pram1, pram2):
    """이것은 두 수를 받아
    두 수의 합을 반환하는 함수
    >>> make_sum(1, 2)
    3
    """
    return pram1 + pram2
```
## 함수 정의
- 함수 정의는 def 키워드로 시작
- def 키워드 이후 함수 이름 작성
- 괄호 안에 매개변수를 정의할 수 있음
- 매개변수(parameter)는 함수에 전달되는 값

- Docstring
    - 함수 body 앞에 선택적으로 작성 가능한 함수 설명서
    
- 함수 반환 값
    - 함수는 필요한 경우 결과를 반환할 수 있음
    - return 키워드 이후에 반환할 값을 명시
    - return 문은 함수의 실행을 종료하고, 결과를 호출 부분으로 반환
    - 함수 내에서 return 문이 없다면 None이 반환됨 

- 함수 호출
    - 함수를 사용하기 위해서는 호출이 필요
    - 함수의 이름과 소괄호를 활용해 호출
    - 필요한 경우 인자(argument)를 전달해야 함
    - 호출 부분에서 전달된 인자는 함수 정의 시 작성한 매개변수에 대입됨

### 함수의 반환 값
print() 함수는 반환 값이 없음
- print() 함수는 화면에 값을 출력하기만 할 뿐 반환(return)값이 없음
- 파이썬에서 반환 값이 없는 함수는 기본적으로 None을 반환한다고 간주되기 때문

- 매개변수(parameter)
    - 함수를 정의할 때, 함수가 받을 값을 나타내는 변수

- 인자(argument)
    - 함수를 호출할 때, 실제로 전달되는 값

### 다양한 인자 종류
1. 위치 인자(Positional Arguments)
- 함수 호출 시 인자의 위치에 따라 전달되는 인자
- 위치 인자는 함수 호출 시 반드시 값을 전달해야 함

2. 기본 인자 값(Default Argument Values)
- 함수 정의에서 매개변수에 기본 값을 할당하는 것
- 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당됨

3. 키워드 인자(Keyword Arguments)
- 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
- 매개변수와 인자를 일치시키지 않고, 특정 매개변수에 값을 할당할 수 있음
- 인자의 순서는 중요하지 않으며, 인자의 이름을 명시하여 전달
- 단, 호출 시 키워드 인자는 위치 인자 뒤에 위치해야 함

4. 임의의 인자 목록
- 정해지지 않은 개수의 인자를 처리하는 인자
- 함수 정의 시 매개변수 앞에 '*'를 붙여 사용
- 여러 개의 인자를 tuple로 처리 내부 동작이 그렇습니다.

5. 임의의 키워드 인자 목록(Arbitray keyword Argument Lists)
- 정해지지 않은 개수의 키워드 인자를 처리하는 인자
- 함수 정의 시 매개변수 앞에 '**'를 붙여 사용
- 여러 개의 인자를 dictionary로 묶어 처리

함수 인자 권장 작성 순서
- 위치 -> 기본 -> 가변 -> 가변 키워드
- 호출 시 인자를 전달하는 과정에서 혼란을 줄일 수 있도록 함
- 단, 모든 상황에 적용되는 절대적인 규칙은 아니며, 상황에 따라 유연하게 조정될 수 있음

## 재귀 함수
함수 내부에서 자기 자신을 호출하는 함수

### 재귀 함수 예시 - 팩토리얼
- factoiral 함수는 자기 자신을 재귀적으로 호출하여 입력된 숫자 n의 팩토리얼을 계산
- 재귀 호출은 n이 0이 될 때까지 반복되며, 종료 조건을 설정하여 재귀 호출이 멈추도록 함
- 재귀 호출의 결과를 이용하여 문제를 작은 단위의 문제로 분할하고, 분할된 문제들의 결과를 조합하여 최종 결과를 도출

```python
def factorial(n):
    # 종료 조건: n이 0이면 1을 반환
    if n == 0:
        return 1
    else:
        # 재귀 호출: n과 n-1의 팩토리얼을 곱한 결과를 반환
        return n * factorial(n - 1)


# 팩토리얼 계산 예시
print(factorial(5))  # 120
```

### 특징
- 특정 알고리즘 식을 표현할 때 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
- 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성

### 재귀 함수 활용 시 기억해야 할 것
- 종료 조건을 명확히 할 것
- 반복되는 호출이 종료 조건을 향하도록 할 것

- 재귀 함수는 메모리 사용량이 많고 느릴 수 있다.
- 스택 오버플로우 조심
- 복잡한 재귀 함수는 오히려 코드의 가독성을 저하시킬 수 있다.

### 재귀 함수 사용하는 이유
- 문제의 자연스러운 표현
    - 복잡한 문제를 간결하고 직관적으로 표현 가능
- 코드 간결성
    - 상황에 따라 반복문보다 알고리즘 코드가 더 간결하고 명확해질 수 있음
- 수학적 문제 해결
    - 수학적 정의가 재귀적으로 표현되는 경우, 직접적인 구현 가능

## 내장 함수(Bulit-in function)
파이썬이 기본적으로 제공하는 함수(별도의 import 없이 사용 가능)

## 함수의 범위
함수는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분

### 범위와 변수 관계
- scope
    - global scope: 코드 어디에서든 참조할 수 있는 공간
    - local scope: 함수가 만든 scope (함수 내부에서만 참조 가능)
- variable
    - global variable: global scopre에 정의된 변수
    - local variable: local scope에 정의된 변수

### 수명주기(lifecycle)
- 변수의 수명주기는 변수가 선언되는 위치와 scope에 따라 결정됨
1. built-in scope
    - 파이썬이 실행된 이후부터 영원히 유지
2. global scope
    - 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
3. local scope
    - 함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지
### 이름 검색 규칙(Name Resolution)
- 파이썬에서 사용되는 이름(식별자)들은 특정한 이름공간에 저장되어 있음
- 아래와 같은 순서로 이름을 찾아 나가며, LEGB Rule이라고 부름
    1. Local scope: 지역 범위(현재 작업 중인 범위)
    2. Enclosed scope: 지역 범위 한 단계 위 범위
    3. Global scope: 최상단에 위치한 범위
    4. Built-in scope: 모든 것을 담고 있는 범위 (정의하지 않고 사용할 수 있는 모든 것)
- 함수 내에세는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음

### LEGB Rule 예시
- sum이라는 이름을 global scope에서 사용함으로써, 기존 built-in scope에 있던 내장함수 sum을 사용하지 못하게 됨\
-> sum을 참조 시 LEGB Rule에 따라 global에서 먼저 찾기 때문
```python
# 내장 함수 sum의 이름을 사용해버려서 오류가 발생하는 예시
print(sum)  # <built-in function sum>
print(sum(range(3)))  # 3
sum = 5
print(sum)  # 5
print(sum(range(3)))  # TypeError: 'int' object is not callable
```
### global 키워드
- 변수의 스코프를 전역 범위로 지정하기 위해 사용
- 일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용
```python
num = 0  # 전역 변수


def increment():
    global num  # num를 전역 변수로 선언
    num += 1


print(num)  # 0

increment()

print(num)  # 1
```
## 함수 이름 작성 규칙
- 소문자와 언더스코어(_) 사용
- 동사로 시작하여 함수의 동작 설명
- 약어 사용 지양

- 함수 이름 구성 요소
    - 동사 + 명사
        - save_user()
    - 동사 + 형용사 + 명사
        - calculate_total_price()
    - get/set 접두사
        - get_username(), set_username()

- 단일 책임 원칙
    - 모든 객체는 하나의 명확한 목적과 책임만을 가져야 함

- 함수 설계 원칙
    1. 명확한 목적
        - 함수는 한 가지 작업만 수행
        - 함수 이름으로 목적을 명확히 표현
    2. 책임 분리
        - 데이터 검증, 처리, 저장 등을 별도 함수로 분리
    3. 유지보수성
        - 작은 단위의 함수로 나누어 관리
        - 코드 수정 시 영향 범위를 최소화

# 패킹
여러 개의 데이터를 하나의 컬렉션으로 모아 담는 과정

기본 원리
- 여러 개의 값을 하나의 튜플로 묶는 파이썬의 기본 동작
- 한 변수에 콤마(,)로 구분된 값을 넣으면 자동으로 튜플로 처리

'*'을 활용한 패킹 (함수 매개변수 작성 시)
- 남는 위치 인자들을 튜플로 묶기
- *를 붙인 매개변수가 남는 위치 인자들을 모두 모아 하나의 튜플로 만듦

'**'을 활용한 패킹 (함수 매개변수 작성 시)
- 남는 키워드 인자들을 딕셔너리로 묶기
- **를 붙인 매개변수가 남는 키워드 인자들을 모두 모아 하나의 딕셔너리로 만듦

# 언패킹
컬렉션에 담겨있는 데이터들을 개별 요소로 펼쳐 놓는 과정

기본 원리
- 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
- '시퀀스 언패킹(Sequence Unpacking)' 또는 '다중 할당(Multiple Assignment)'이라고 부름

# 함수의 반환
함수의 return, 반환의 원칙
- 파이썬 함수는 언제나 단 하나의 값(객체)만 반환할 수 있음
- 여러 값을 반환하는 경우에도 하나의 튜플로 패킹하여 반환

파이썬 함수의 반환 핵심
1. 파이썬 함수는 오직 하나의 값(객체)만 return 할 수 있음
2. return a, b, c 처럼 콤마를 사용하면, 파이썬이 값들을 하나의 튜플로 자동 패킹하여 반환
3. 반환된 튜플은 각 변수에 언패킹하여 사용할 수 있음

# 람다 표현식
- 익명 함수를 만드는 데 사용되는 표현식
- 한 줄로 간단한 함수를 정의

람다 표현식 구조
- lambda 키워드
    람다 함수를 선언하기 위해 사용되는 키워드
- 매개변수
    - 함수에 전달되는 매개변수들
    - 여러 개의 매개변수가 있을 경우 쉼표로 구분
- 표현식
    - 함수의 실행되는 코드 블록으로, 결과값을 반환하는 표현식으로 작성