# 9/26

# Django Form
**HTML 'form'**

지금까지 사용자로부터 데이터를 제출 받기위해 활용한 방법 그러나 비정상적 혹은 악의적인 요청을 필터링 할 수 없음

**유효성 검사**

수집한 데이터가 정확하고 유효한지 확인하는 과정

- Django Form의 유효성 검사는 사용자가 입력한 데이터가 올바른 형식인지 자동으로 점검하는 기능을 제공한다
- 예를 들어, 필수 입력 값이 비어 있거나 잘못된 이메일 형식을 입력하면 오류를 알려준다.
- 이 과정을 통해 서버에 잘못된 데이터가 저장되지 않도록 보호할 수 있다.

**유효성 검사 구현의 어려움**
- 유효성 검사를 구현하기 위해서는 입력 값, 형식, 중복, 보안 등 많은 것들을 고려해야 함
- 이런 과정과 기능을 직접 개발하는 것이 아닌 Django가 제공하는 Form을 사용

## Form class
Django Form

사용자 입력 데이터를 수집하고, 처리 및 유효성 검사를 수행하기 위한 도구

Form Class 정의
- Form Class를 상속받아 내용과 제목에 대한 사용자 입력을 받는 ArticleForm을 정의하는 방법
```python
# articles/forms.py

from django import forms

class ArticleForm(forms.Form):
  title = forms.CharlField(max_length=10)
  content = forms.CharField()
```
Form Class를 적용한 new logic
- view 함수 new 변경
```python
# articles/views.py
from .forms import ArticleForm

def new(request):
  form = ArticleForm()
  context = {
    'form': form,
  }
  return render(request, 'articles/new.html', context)
```

- new 페이지에서 form 인스턴스 출력
```
<!-- articles/new.html -->
<h1>NEW</h1>
<form action = "{% url 'articles:create' %}" method = "POST">
  {% csrf Token %}
  {{ form }}
  <input type="submit">
</form>
```

![alt text](<images/09_29/스크린샷 2025-09-29 121835.png>)

Form class 가 대체하는 것

![alt text](<images/09_29/스크린샷 2025-09-29 121918.png>)

## Widgets
HTML 'input' element의 표현을 담당

- Django Form의 widgets은 각 필드가 HTML에서 어떻게 렌더링 될지를 결정한다.
- 예를 들어, TextInput, Select, CheckboxInput 등 다양한 위젯 클래스를 사용해 입력 방식과 속성을 세부 조정 할 수 있다.

Widget 적용
- Widget은 단순히 input 요소의 속성 및 출력되는 부분을 변경하는 것

![alt text](<images/09_29/스크린샷 2025-09-29 122303.png>)

# Django ModelForm
Form

사용자 입력 데이터를 DB에 저장하지 않을 때 (ex: 검색, 로그인)

ModelForm

사용자 입력 데이터를 DB에 저장해야 할 때 (ex: 게시글 작성, 회원가입)

Model과 연결된 Form을 자동으로 생성해주는 기능을 제공
- ModelForm은 Form 클래스와 Model 클래스를 결합한 형태로, 모델 필드를 기반으로 입력 폼을 자동 생성해준다.
- 데이터 수집과 저장 과정을 동시에 처리할 수 있도록 도와준다.

ModelForm class 정의
- 기존 ArticleForm 클래스 수정
```python
# articles/forms.py

from django import forms
from .models import Article

class ArticleForm(forms.ModelForm):
  class Meta:
    model = Article
    fields = '__all__'
```

Django ModelForm

![alt text](<images/09_29/스크린샷 2025-09-29 122824.png>)

ModelForm class가 대체하는 것

![alt text](<images/09_29/스크린샷 2025-09-29 122850.png>)

## Meta class
ModelForm의 정보를 작성하는 곳

- Meta class는 ModelForm 내부에서 어떤 모델과 연결할지, 어떤 필드를 사용할지 등을 정의하는 설정 공간이다.
- 폼의 동작 방식을 제어하는 핵심 역할을 한다.

'fields' 및 'exclude'속성
- exclude 속성을 사용하여 모델에서 포함하지 않도록 필드를 지정할 수도 있음

```python
# articles/forms.py

class ArticleForm(forms.ModelForm):
  class Meta:
    model = Article
    fields = ('title')

class ArticleForm(forms.ModelForm):
  class Meta:
    model = Article
    exclude = ('title',)
```

Meta class 주의사항

- Django에서 ModelForm에 대한 추가 정보나 속성을 작성하는 클래스 구조를 Meta클래스로 작성 했을 뿐이며, 파이썬의 inner class와 같은 문법적인 관점으로 접근하지 말 것

## ModelForm 적용
ModelForm을 적용한 create 로직

```python
# articles/views.py
from .forms import ArticleForm

def create(request):
  form = ArticleForm(request.POST)
  if form.is_valid():
    article = form.save()
    return redirect('articles:detail', article.pk)

    context = {
      'form': form,
    }
    return render(request, 'articles/new.html', context)
```
- 제목 input에 공백을 입력 후 제출 시 에러 메시지 출력 확인 -> 유효성 검사의 결과

is_valid()

여러 유효성 검사를 실행하고, 데이터가 유효한지 여부를 Boolean으로 반환

공백 데이터가 유효하지 않은 이유와 에러메시지가 출력되는 과정

- 별도로 명시하지 않았지만 모델 필드에는 기본적으로 빈 값은 허용하지 않는 제약조건이 설정 되어있음
- 빈 값은 is_valid()에 의해 False로 평가되고 form 객체에는 그에 맞는 에러 메시지가 포함되어 다음 코드로 진행됨

![alt text](<images/09_29/스크린샷 2025-09-29 123911.png>)


ModelForm을 적용 edit 로직
```python
# articles/views.py

def edit(request, pk):
  article = Article.objects.get(pk=pk)
  form = ArticleForm(instance=article)
  context = {
    'article': article,
    'form': form,
  }
  return render(request, 'articles/edit.html', context)
```

```
<!-- articles/edit.html -->

<h1>EDIT</h1>
<form action = "{% url 'articles:update' article.pk %}" method="POST">
  {% csrf_token %}
  {{ form }}
  <input type="submit">
</form>
```

ModelForm을 적용한 update 로직
```python
# articles/views.py

def update(request, pk):
  article = Article.objects.get(pk=pk)
  form = ArticleForm(request.POST, instace=article)
  if form.is_valid():
    from.save()
    return redirect('articles:detail', article.pk)
  context = {
    'article': article,
    'form': form,
  }
  return render(request, 'artlcies/edit.html', context)
```
## save 메서드
데이터베이스 객체를 만들고 저장하는 ModelForm의 인스턴스 메서드

- 폼 데이터가 유효한 경우, save() 메서드를 호출하면 모델 인스턴스를 생성하고 데이터베이스에 저장된다.
- instance 인자를 통해 새 객체 생성과 기존 객체 수정도 구분할 수 있다.
- 이 과정을 통해 코드 없이 손쉽게 DB 연동이 가능하다.

save() 메서드가 생성과 수정을 구분하는 법
- 키워드 인자 instance 여부를 통해 생성할 지, 수정할 지를 결정
```python
# CREATE
form = ArticleForm(request.POST)
form.save()

# UPDATE
form = ArticleForm(request.POST, instance=article)
form.save()
```

Django Form 정리
- "사용자로부터 데이터를 수집하고 처리하기 위한 강력하고 유연한 도구"
- HTML form의 생성, 데이터 유효성 검사 및 처리를 쉽게 할 수 있도록 도움

# HTTP 요청 다루기

## View 함수 구조 변화
new & create view 함수간 공통점과 차이점

공통점
- "데이터 생성을 구현하기 위함"

차이점
- "new는 GET method 요청만을, create는 POST method 요청만을 처리"

view 함수 구조화의 목적

HTTP request method 차이점을 활용해 동일한 목적을 가지는 2개의 view 함수를 하나로 구조화

## new & create 함수 결합
```python
def new(request):
  form = ArticleForm()
  context = {
    'form': form,
  }
  return render(request, 'articles/new.html', context)

def create(request):
  form = ArticleForm(request.POST)
  if form.is_valid():
    article = form.save()
    return redirect('articles:detail', article.pk)
  context = {
    'form': form,
  }
  return render(request, 'articles/new.html', context)
```
## edit & update 함수 결합

```python
def create(request):
  # new와 create view 함수의 공통점과 차이점을 기반으로 하나의 함수로 결합

  # 두 함수의 유일한 차이점이었던 request method 에 따른 분기
  if request.method == 'POST':
    # POST일 때는 과거 create 함수 구조였던 객체 생성 및 저장 로직 처리
    form = ArticleForm(request.POST)
    if form.is_valid():
      article = form.save()
      return redirect('article:detail', article.pk)
  else:
    # POST가 아닐 때는 과거 new 함수에서 진행했던 form 인스턴스 생성
    form = ArticleForm()

  context = {
    'form': form,
  }
  return render(request, 'articles/new.html', context)
```

![alt text](<images/09_29/스크린샷 2025-09-29 151450.png>)

기존 new 관련 코드 수정

1. 사용하지 않게 된 new url 제거

![alt text](<images/09_29/스크린샷 2025-09-29 154012.png>)

2. new 관련 키워드를 create로 변경

![alt text](<images/09_29/스크린샷 2025-09-29 154048.png>)
![alt text](<images/09_29/스크린샷 2025-09-29 154114.png>)

request method에 따른 요청의 변화
(GET) `articles/create/` 게시글 생성 페이지를 줘!
(POST) `articles/create/` 게시글을 생성해줘!

## edit & update 함수 결합
```python
# articles/views.py

def update(request, pk):
  article = Article.objects.get(pk=pk)
  if request.method == 'POST':
    form = ArticleForm(request.POST, instance=article)
    if form.is.valid():
      form.save()
      return redirect('articles:detail', article.pk)
  else:
    form = ArticleForm(instance=article)
  context = {
    'article':article,
    'form': form,
  }
  return render(request, 'articles/update.html', context)
```

기존 edit 관련 코드 수정
- 사용하지 않는 edit url 제거

![alt text](<images/09_29/스크린샷 2025-09-29 175421.png>)

- edit 관련 키워드를 update로 변경

![alt text](<images/09_29/스크린샷 2025-09-29 175508.png>)

# 참고
## ModelForm의 키워드 인자 구성

## Widgets 응용

## 필드를 수동으로 렌더링