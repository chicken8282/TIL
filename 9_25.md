# ORM with view

## Read

단일 게시글 조회

최종 결과화면 미리보기
![alt text](<images/09_25/스크린샷 2025-09-25 090504.png>)

단일 게시글 고회 구현
```python
# articles/urls.py

urlpatterns = [
  ...
  path('<int:pk>/', views.detail, name = 'detail'),
]

# articles/views.py
def detail(request, pk):
  article = Article.objects.get(pk = pk)
  context = {
    'article': article,
  }
  return render(request, 'articles/detail.html', context)
```
```
<!-- templates/articles/detail.html -->
<h1>Detail</h1>
  <h2>{{ article.pk }} 번째 글</h2>
  <hr>
  <p>제목: {{ article.title }}</p>
  <p>내용: {{ article.content }}</p>
  <p>작성일: {{article.created_at}}</p>
  <p>수정일: {{article.updated_at}}</p>
  <hr>
  <a href="{% url "articles:index" %}">[메인 페이지로]</a>
```
- 단일 게시글 이동 페이지 링크 구현
```
{% for article in articles %}
    <p>글 번호: {{ article.pk }}</p>
    <a href="{% url "articles:detail" article.pk %}">
      글 제목: {{ article.title }}
    </a>
    <p>글 내용: {{ article.content }}</p>
    <hr>
  {% endfor %}
```
# Create
Create 로직을 구현하기 위해 필요한 view 함수의 개수는?

![alt text](<images/09_25/스크린샷 2025-09-25 095621.png>)

new - 페이지 렌더링 기능 구현
- 최종 결과화면 미리보기
![alt text](<images/09_25/스크린샷 2025-09-25 095712.png>)
# HTTP request methods
## HTTP
네트워크 상에서 데이터(리소스) 를 주고 받기위한 약속

HTTP request methods란?

데이터에 대해 수행을 원하는 작업(행동)을 나타내는 것
  - 서버에서 원하는 작업의 종류를 알려주는 역할

대표적인 메서드

1. GET
- 리소스 조회
  - URL에 데이터가 노출됨
  - 캐싱 가능
2. POST
  - 데이터 생성/전송
    - 요청 본문에 데이터
    - 데이터 노출 없음

## GET method
서버로부터 데이터를 요청하고 받아오는 데(조회) 사용

- 주로 검색 쿼리 전송, 웹 페이지 요청, 그리고 API에서 데이터를 조회하는 것과 같이 서버로부터 데이터를 요청하고 받아오는 데 사용

'GET' Method 특징
1. 데이터 전송
- URL의 쿼리 문자열(Query String)을 통해 데이터를 전송
- http://127.0.0.1:8000/articles/create/?title=제목&content=내용
2. 데이터 제한
- URL길이에 제한이 있어 대량의 데이터 전송에는 적합하지 않음
3. 브라우저 히스토리
- 요청 URL이 브라우저 히스토리에 남음
4. 캐싱
- 브라우저는 GET 요청의 응답을 로컬에 저장할 수 있음
- 동일한 URL로 다시 요청할 때, 서버에 접속하지 않고 저장된 결과를 사용
- 페이지 로딩 시간을 크게 단축

## POST method
서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제) 하는 데 사용

POST 메서드는 주로 로그인 정보 제출, 파일 업로드, 새 데이터 생성(예: 새 게시글 작성), 그리고 API에서 데이터 변경을 요청하는 것과 같이 클라이언트가 서버로 데이터를 전송하여 서버의 상태를 변경할 때 사용한다.

'POST' Method 특징
1. 데이터 전송
- HTTP Body를 통해 데이터를 전송
2. 데이터 제한
- GET에 비해 더 많은 양의 데이터를 전송할 수 있음
3. 브라우저 히스토리
- POST 요청은 바루엊 히스토리에 남지 않음
4. 캐싱
- POST 요청은 기본적으로 캐시 할 수 없음
- POST 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문


# HTTP response status code
Create 로직 수정 - "http method POST로 변경"
- new.html의 form 요청은 새로운 article(새로운 데이터)을 생성하는 요청
  - POST method로 서버에 전달되는 것이 적절함
```
<!-- templates/articles/new.html -->

<form action="{% url "articles:create" %}" method="POST">
    {% csrf_token %}
    <div>
      <label for="title">Title: </label>
      <input type="text" name="title" id = 'title'>
    </div>
    <div>
      <label for="content">Content: </label>
      <textarea name="content" id="content"></textarea>
    </div>
    <input type="submit">
  </form>
```
```
def create(request):
    title = request.POST.get('title')
    content = request.POST.get('content')

    article = Article(title = title, content = content)
    article.save()

    return redirect('articles:detail', article.pk)
```

- 게시글 작성 후 403 응답 확인

![alt text](<images/09_25/스크린샷 2025-09-25 115140.png>)

## HTTP response status code
서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자

클라이언트는 이 코드를 통해 요청이 성공했는지, 실패했는지, 아니면 추가적인 조치가 필요한지 즉시 파악할 수 있다. 이를 통해 웹 브라우저는 적절한 메시지를 사용자에게 표시하거나, 개발자는 문제 해결을 위한 단서를 얻게 된다.

403 Forbidden
- 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미

403 Forbidden 응답으로 거절 된 이유
- "CSRK token이 누락되었다" 라는 응답

![alt text](<images/09_25/스크린샷 2025-09-25 115347.png>)

## CSRF(Cross-Site-Request-Forgery)
사이트 간 요청 위조

사용자가 자신의 의지와는 무관하게 공격자가 의도한 행동 (글쓰기, 정보수정, 송금 등)을 특정 웹사이트에 요청하게 만드는 해킹 방식

CSRF(위조된 인감도장)
1. 신뢰할 수 있는 관계 (로그인)
- 사용자는 은행(예: bank.com)에 정상적으로 로그인하여, 은행은 사용자를 신뢰하고 있다는 증표(세션 쿠키)를 브라우저에 발급. 이 쿠키가 바로 당신의 '인감도장'.
2. 악성 위임장 (악성 링크)
- 사기꾼(해커)은 "무료 경품 이벤트!"와 같은 미끼 링크를 사용자에게 보냄. 이 링크의 실제 내용은 "내 돈 100만원을 해커에게 송금하라"는 내용이 담긴, 당신의 인감도장만 찍으면 되는 '위조된 위임장'
3. 나도 모르는 날인 (요청 전송)
- 사용자가 미끼 링크를 클릭하는 순간, 당신의 브라우저는 자기도 모르게 bank.com에 위조된 위임장(송금 요청)을 보냄. 이때 브라우저는 bank.com에 보낼 때마다 인감도장 (세션 쿠키)을 자동으로 찍어서 보냄
4. 은행의 착각 (공격 성공)
- 은행 입장에서는 정상적인 인감도장이 찍힌 위임장이 도착했으므로, 이 요청이 당신의 진짜 의사라고 믿고 송금을 실행.

CSRF 공격의 방어
- Django는 이러한 공격을 막기 위해 CSRF 토큰이라는 안전장치를 사용
- 이는 위임장에 진짜 서명이 있는지 확인하는 것처럼, 모든 중요한 요청에 대해 "내가 직접 보낸 요청이 맞다"는 일회용 비밀 코드를 함께 보내도록 하여 위조된 요청을 막아줌

CSRF Token 적용
- DTL의 csrf_token 태그를 사용해 손쉽게 사용자에게 토큰 값을 부여
- 요청 시 토큰 값도 함께 서버로 전송될 수 있도록 하는 것
```
<!-- teamplates/articles/new.html -->
<h1>New</h1>
  <form action="{% url "articles:create" %}" method="POST">
    {% csrf_token %}
```

![alt text](<images/09_25/스크린샷 2025-09-25 120048.png>)

요청 시 CSRF Token을 함께 보내야 하는 이유
- Django 서버는 해당 요청이 DB에 데이터를 하나 생성하는 (DB에 영향을 주는) 요청에 대해 "Django가 직접 제공한 페이지에서 데이터를 작성하고 있는 것인지"에 대한 확인 수단이 필요한 것
- 겉모습이 똑같은 위조 사이트나 정상적이지 않은 요청에 대한 방어 수단
- 기존 요청 형태
  - 요청 데이터 -> 게시글 작성
- 변경 요청 형태
  - 요청 데이터 + 인증 토큰 -> 게시글 작성

그런데 왜 POST일 때만 TOKEN을 확인할까?
- POST는 단순 조회(GET)와 달리 리소스의 변경 (생성, 수정, 삭제)을 요청하는 의미와 기술적 특성을 지님
- DB에 조작을 가하는 요청은 반드시 인증 수단이 필요\
-> 데이터베이스에 대한 변경사항을 만드는 요청이기 때문에 토큰을 사용해 최소한의 신원 확인을 하는 것

게시글 작성 결과
- 더 이상 URL에 Query String 형태로 보냈던 데이터가 표기되지 않음 (기존 GET method 방식)

![alt text](<images/09_25/스크린샷 2025-09-25 141502.png>)

- 게시글 생성 후 개발자 도구를 사용해 Form Data가 전송되는 것 확인

![alt text](<images/09_25/스크린샷 2025-09-25 141444.png>)

# Redirect
현재 문제 상황: 게시글 작성 후 응답 방식
- 현재 서비스는 게시글 작성 (POST 요청) 이후, "게시글이 성공적으로 작성되었습니다"와 같은 완료 메시지 페이지를 직접 반환함, 게시글 저장 후 페이지를 응답하는 것은 POST 요청에 대한 적절한 응답이 아님
- 이는 후속 행동(예: 새로고침, 뒤로 가기)에서 예기치 않은 동작을 유발할 수 있음
# Delete

# Update

# 참고