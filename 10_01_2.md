# 10/1

# 회원정보 수정
- User 객체를 Update 하는 과정
- 수정할 대상 User 객체를 가져오고, 입력받은 새로운 정보로 기존 내용을 갱신

회원정보 수정 페이지 작성
- 회원정보 수정 경로 url 생성
```python
# account/urls.py

app_name = 'accounts'
urlpatterns = [
  ...,
  path('update/', views.update, name='update'),
]
```

UserChangeForm()
- 회원정보 수정 시 사용자 입력 데이터를 받는 built-in ModelForm
- ModelForm이기 때문에, 유효성 검사를 통과한 데이터로 기존 User 객체의 내용을 갱신하고 저장 (주로 관리자 페이지에서 사용)

![alt text](<images/10_01_2/스크린샷 2025-10-01 104530.png>)
- [복습] 커스텀 유저 모델을 사용을 하기 위해서 Form을 다시 작성
- Custom User model을 사용할 수 있도록 상속 후 일부분만 재작성
```python
# accounts/forms.py

from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserChangeForm

class CustomUserChangeForm(UserChangeForm):
  class Meta(UserChangeForm.Meta):
    model = get_user_model()
```

- .../accounts/update/url 로 요청이 들어왔을 때 실행할 update 함수 작성
- 회원정보 수정에 사용할 데이터를 입력 받는 CustomUserChangeForm built-in form 사용

```python
# accounts/views.py

from .forms import CustomUserhangeForm

def update(request):
  if request.method == "POST":
    pass
  else:
    form = CustomUserChangeForm(instance=request.user)
  context = {
    'form': form,
  }
  return render(request, 'accounts/update.html', context)
```

- 회원가입을 위해 작성한 정보를 서버에 안전하게 전송하기 위해 "POST 방식"을 사용
- 서버로부터 전달받은 CustomUserChangeForm을 화면에 출력

![alt text](<images/10_01_2/스크린샷 2025-10-01 105902.png>)

- 메인 페이지에서 회원정보 수정 페이지에 접근할 수 있는 태그 생성
```
<!-- accounts/index.html -->

<a href="{% url 'accounts:update' %}>회원정보 수정</a>
```
UserChangeForm 사용시 문제점
- User모델의 모든 정보들(fields)까지 모두 출력됨
- 일반 사용자들이 접근하면 안되는 정보는 출력하지 않아야 함

-> CustomUserChangeForm에서 출력 필드를 다시 조정하기

![alt text](<images/10_01_2/스크린샷 2025-10-01 112307.png>)

CustomUserChangeForm 출력 필드 재정의
- User Model의 필드 목록 확인

![alt text](<images/10_01_2/스크린샷 2025-10-01 112357.png>)

회원정보 수정 로직 완성
```python
# accounts/views.py

@login_required
def update(request):
  if request.method == 'POST':
    form = CustomUserChangeForm(request.POST, instance=request.user)
    if form.is.valid():
      form.save()
      return redirect('articles:index')
  else:
    form = CustomUserChangeForm(instance=request.user)
  context = {
    'form': form,
  }
  return render(request, 'accounts/update.html', context)
```

# 비밀번호 변경
- 인증된 사용자의 Session 데이터를 Update 하는 과정
- 기존 비밀번호를 통해 사용자를 인증하고, 새로운 비밀번호를 암호화하여 갱신

- django는 비밀번호 변경 페이지를 회원정보 수정 form 하단에서 별도 주소로 안내

![alt text](<images/10_01_2/스크린샷 2025-10-01 112801.png>)

- Django에서 안내하는 비밀번호 변경 URL에 맞춰서 작성
```python
# accounts/urls.py

app_name = 'accounts'
urlpatterns = [
  ...,
  path('password/', views.password, name = 'password'),
]
```

- .../accounts/password/url 로 요청이 들어올 때 실행할 password 함수 작성
- 비밀번호 변경에 사용할 데이터를 입력 받는 PasswordChangeForm built-in form 사용

![alt text](<images/10_01_2/스크린샷 2025-10-01 113021.png>)

**PasswordChangeForm()**
- 비밀번호 변경 시 사용자 입력 데이터를 받는 built-in Form
- 일반 'Form'이며, 유효성 검사 (기존 비밀번호 확인, 새 비밀번호 일치 여부)를 통과한 데이터로 사용자의 비밀번호를 안전하게 암호화하여 갱신하는 역할을 수행

![alt text](<images/10_01_2/스크린샷 2025-10-01 113145.png>)

```python
# accounts/views.py

def password(request):
  if request.method == "POST":
    form = PasswordChangeForm(user = request.user, data = request.POST)
    if form.is_valid():
      user = form.save()
      return redirect('articles:index')
  else:
    form = PasswordChangeForm(request.user)
  context = {
    'form': form,
  }
  return render(request, 'accounts/password.html', context)
```

## 세션 무효화 방지
- 비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어 버려 로그인 상태가 유지되지 못하고 로그아웃 처리됨
- 비밀번호가 변경되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문

-> 암호 변경 시 세션 무효화를 막는 방법은?

암호 변경 시 세션 무효화를 막아주는 함수
`update_session_auth_hash(request, user)`
- 암호가 변경되면 새로운 password의 Session Data로 기존 session을 자동으로 갱신
- update_session_auth_hash를 password 함수에 적용

```python
# accounts/views.py
from django.contrib.auth import update_session_auth_hash

def password(request):
  if request.method == "POST":
    form = PasswordChangeForm(request.user, request.POST)
    if form.is_valid():
      user = form.save()
      update_session_auth_hash(request, user)
      return redirect('articles:index')
```

# 비밀전호 암호화
암호화의 중요성
- 많은 해킹사태가 발생하고 있고, 데이터가 유출되더라도 그 내용을 알 수 없도록 하는 암호화는 특히 중요

**우리가 사용하는 비밀번호는 어떻게 저장되고 있을까?**

비밀번호를 복원이 불가능한 고정된 길이의 문자열로 변환 후 저장 => 보안에 필수

-> 비밀번호를 복원이 불가능한 고정된 길이로 바꾸는 과정을 "해시(hash)"라고 함

고정된 길이의 문자열로 변환하는 이유
- 보안성: 변환된 문자열의 길이가 다르다면, 길이만 보고도 원래 비밀번호의 길이를 유추할 수 있음
- 일관성: 길이가 동일하기 때문에 저장 공간을 예측하고 설계하기 쉬우며, 검색/비교하는 처리 속도도 일정하게 유지할 수 있다.

**해시(Hash)**

임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것

- 데이터를 고정된 크기의 값으로 변환하는 과정
- 작은 변화에도 해시 값이 크게 달라지는 특성으로 인해 변조 여부를 쉽게 확인할 수 있음
- 입력값이 들어오더라도 해시 함수에 의해서 다른 값으로 바뀌며, 동일한 값은 항상 동일한 해시값을 생성

![alt text](<images/10_01_2/스크린샷 2025-10-01 114834.png>)

**해시함수(Hash function)**

임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수

- 어떤 길이의 데이터든 넣을 수 있고, 항상 고정된 길이의 결과물 (해시 값)이 나온다.
- 입력 값으로 해시 값을 만들 수는 있지만, 해시 값만 보고 원래 입력값을 알아낼 수 없다.(단방향)
- 입력 값이 단 한 글자만 달라져도 해시 값은 완전히 달라진다.(눈사태 효과)
- 같은 입력 값을 넣으면 언제나 똑같은 해시 값이 나온다.

Django는 기본적으로 SHA-256 해시 함수를 사용해서 암호화
- 입력한 비밀번호의 길이와는 상관없이 동일한 길이의 해시 값을 생성
- 1글자만 다르더라도 전혀 다른 해시 값을 생성

![alt text](<images/10_01_2/스크린샷 2025-10-01 114959.png>)

**SHA-256(Secure Hash Algorithm - 256)**

안전한 해시 알고리즘으로, 어떤 데이터를 입력하든 256비트 길이의 결과물을 만들어 냄

해시 함수를 활용해 단방향 암호화를 하면 더 이상 문제가 없을까?
- 비밀번호를 해시 값으로 저장하면 공격자가 유출된 데이터베이스를 봐도 원래 비밀번호를 알 수 없으니 안전해 보일 수 있음
- 하지만 공격자들은 해시값을 미리 계산해두는 방식으로 공격을 시도
  
-> 이 방식이 바로 '레인보우 테이블'공격

**레인보우 테이블(Rainbow Table)**
- 공격자가 자주 사용되는 비밀번호들(예: 123456, qwer1234, ...)을 미리 수백만, 수십억 개를 해시로 변환해 저장해 둔 거대한 정답지
  
**공격 방식**
1. 공격자가 DB를 탈취해 사용자의 비밀번호 해시 값을 얻음
2. 해시 값을 공격자 자신의 레인보우 테이블에서 검색
3. 테이블에서 일치되는 값을 찾아내면서, 역방향으로 되돌리지 않고 비밀번호를 알아내는 데 성공

![alt text](<images/10_01_2/스크린샷 2025-10-01 115455.png>)

그러면 레인보우 테이블 공격은 어떻게 방어할까?
- 공격자가 아무리 거대한 레인보우 테이블을 가지고 있더라도, 사용자의 해시 값이 레인보우 테이블에 없도록 해시 값을 만들면 됨
- 같은 비밀번호라도 사용자마다 **"임의의 문자열"**을 비밀번호에 붙여서 해시 암호화를 진행
  - **임의의 문자열**이 추가된 상태로 해시 값을 만들기 때문에 눈사태 효과에 의해 같은 비밀번호도 다른 해시 값이 나옴 -> 여기서 **"임의의 문자열"** 역할을 하는 것이 바로 **솔트(Salt)**

**솔트 (Salt)**
- 각 사용자마다 고유하게 생성된 임의의 문자열(솔트)을 비밀번호에 덧붙여서 해시 값을 생성
- 이 솔트(Salt)는 해시 값과 함께 데이터베이스에 저장

![alt text](<images/10_01_2/스크린샷 2025-10-01 115950.png>)

솔트(Salt)로 레인보우 테이블 공격을 막았으니, 안전할까?
- 공격자는 이제 미리 만들어 둔 답안지를 쓸 수 없어짐
- 그래서 단순하지만 확실한 방법으로써 가능한 모든 비밀번호를 하나씩 직접 대입 해보는 방식으로 공격
- 이 방식은 현대 컴퓨터의 엄청난 속도 때문에 생각보다 훨씬 위협적
  - 최신 GPU는 초당 약 1500억 번이상 추측할 수 있음

-> 이 방식이 바로 "무차별 대입 공격(Brute-force Attack)"

**무차별 대입 공격(Brute-force Attack)**
- 가장 원시적이지만 강력한 방법으로써 가능한 모든 비밀번호를 하나씩 대입하는 방식
- 이 공격은 시간과의 싸움이며, 현대 컴퓨터의 빠른 연산 속도가 공격자의 무기가 됨

![alt text](<images/10_01_2/스크린샷 2025-10-01 120326.png>)

무차별 대입 공격은 어떻게 막을까?
- 해결책은 "연산 속도를 늦추는 것"이 핵심
- 연산 속도를 늦추기 위해서 의도적으로 비밀번호 검증 과정을 느리게 만듦
  - 느리게 만들기 위해서 의도적으로 해시 연산을 수십만 번 반복시켜, 공격 속도를 늦춤 -> 이 방식이 바로 "키 스트레칭(Key Stretching)"

**키 스트레칭(Key Stretching)**
- 솔트(Salt)를 적용한 해시 함수를 수만 ~ 수십만 번 반복하여 연산 시간을 의도적으로 늘리는 기법
- '속도'가 무기인 무차별 대입 공격 (Brute-force Attack)을 방어할 수 있음
- Django는 이 키 스트레칭을 구현하기 위해서 PBKDF2라는 검증된 알고리즘을 기본으로 사용
  - 최근에는 더 강력한 보안을 제공하는 Argon2, bcrypt 같은 알고리즘도 지원

![alt text](<images/10_01_2/스크린샷 2025-10-01 121645.png>)

Django에서의 비밀번호 암호화

![alt text](<images/10_01_2/스크린샷 2025-10-01 121723.png>)

1. <algorithm>: 어떤 알고리즘을 쓰는 지
2. <iterations>: 키 스트레칭 횟수
3. <salt>: 생성된 솔트
4. <hash>: 생성된 최종 해시

## 비밀번호 암호화 정리
- 암호화 과정을 이해한 후, 검증된 프레임워크의 보안 기능을 신뢰하고 사용하기
  - 보안은 매우 어렵고 복잡한 분야이며, Django 공식에도 가급적 재발명하지 않을 것을 권장하고 있음
- 단순히 코드를 복사해서 붙여넣는 것을 넘어, 이 기능이 '왜' 이렇게 만들어졌는지 이해하면, 더 견고하고 안전한 어플리케이션을 만들 수 있음
- 사용자는 우리의 서비스를 믿고 소중한 개인정보를 맡기고, 그들의 데이터를 안전하게 지키는 것은 개발자의 **'가장 기본적인 책임이자 직업윤리'**

# 참고

## 비밀번호 초기화
- 비밀번호를 잊어버린 사용자가 이메일을 활용하여 비밀번호를 다시 설정하는 과정

1. 비밀번호를 찾으려고 하는 이메일 입력
- Django에서 제공하는 비밀번호 관련 기능을 활용하기 위해 django.contrib.auth.urls를 crud/urls.py에 포함

![alt text](<images/10_01_2/스크린샷 2025-10-01 122254.png>)

- .../accounts/ 만 입력해보고, 제공하는 url 목록을 확인
- 제공되는 url 목록에서 'password_rest' 경로를 입력해보고, 비밀번호 초기화 페이지로 접근

![alt text](<images/10_01_2/스크린샷 2025-10-01 122357.png>)

2. 이메일로 비밀번호 재설정 링크를 전송
- 비밀번호를 찾으려고 하는 이메일을 작성하고 'Reset my password'버튼을 눌러 이메일 전송

![alt text](<images/10_01_2/스크린샷 2025-10-01 122500.png>)

- 이메일 관련 설정을 따로 하지 않았기 때문에 전송 실패

![alt text](<images/10_01_2/스크린샷 2025-10-01 122613.png>)

- Django에서는 이메일을 보낸 내용을 콘솔에서 볼 수 있는 기능을 제공
- settings.py에서 EMAIL_BACKEND 세팅 후 다시 이메일 전송하기

![alt text](<images/10_01_2/스크린샷 2025-10-01 122725.png>)

- 콘솔창에 비밀번호 초기화 설정 페이지 안내 이메일을 확인하고, 해당 링크 들어가기

![alt text](<images/10_01_2/스크린샷 2025-10-01 122810.png>)

3. 비밀번호 재설정 페이지에서 새로운 비밀번호 설정
- 새로운 비밀번호 설정 후, 비밀번호 설정 완료 페이지 보여주기

![alt text](<images/10_01_2/스크린샷 2025-10-01 122851.png>)

4. 초기화 후 다시 로그인
- 변경한 비밀번호로 로그인

![alt text](<images/10_01_2/스크린샷 2025-10-01 122923.png>)

Django에서는 수많은 '완성된 기능 모듈'을 제공
- 단순하게 '비밀번호 초기화'기능을 구현한 것이 아니라, 잘 만들어진 모듈을 활용하는 법을 학습한 것
  - `Django.contrib.auth.urls`외에도 admin, sessions, stiemaps등 다양한 기능을 제공
  - 이메일 서버가 없어도 테스트가 가능한 것처럼, 실제 서비스 환경을 흉내 내는 많은 모듈을 제공하고 있음
- 이런 다양한 모듈을 활용해서 개발 기술을 숙련하는 데 활용

## PasswordChangeForm 인자 순서
PasswordChangeForm이 다른 Form과 달리 user객체를 첫번째 인자로 받는 이유
- 부모 클래스인 SetPasswordForm의 생성자 함수 구성을 따르기 때문

## Auth built-in form 코드
아래 링크에 들어가서 각 Form의 구조를 살펴보자
- UserChangeForm()
  - https://github.com/django/django/blob/5.2/django/contrib/auth/forms.py#L292

- PasswordChangeForm()
  - https://github.com/django/django/blob/5.2/django/contrib/auth/forms.py#L531