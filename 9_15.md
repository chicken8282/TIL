# 9/15

# 그래프의 기본과 탐색

## 그래프

아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현

- 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
- |V|: 정점의 개수, |E|: 그래프에 포함된 간선의 개수라 할 때, |V| 개의 정점을 가지는 그래프는 최대 |E| = |V| * (|V| - 1) / 2개의 간선을 가질 수 있다.
- 예: 5개 정점이 있는 그래프의 최대 간선 수는 10(=5*4/2)개 이다.

그래프 유형
- 무향(무방향) 그래프 (Undireceted Graph)
- 유향(방향) 그래프 (Directed Graph)
- 가중치 그래프 (Weighted Graph)
- 사이클 없는 방향 그래프 (DAG, Directed Acyclic Graph)

![alt text](<images/09_15/스크린샷 2025-09-15 140706.png>)

그래프 유형
- 완전 그래프: 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

인접 정점
- 인접(Adjacency)
- 두 개의 정점에 간선이 존재 (연결됨)하면 서로 인접해 있다고 합니다.
- 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있습니다.

그래프 경로
- 경로란 간선들을 순서대로 나열한 것
  - 간선들: (0, 2), (2, 4), (4, 6)
  - 정점들: 0 - 2 - 4 - 6
- 경로 중 한 정점을 최대한 한번만 지나는 경로를 단순경로라고 함
  - 0 - 2 - 4 - 6, 0 - 1 - 6
- 시작한 정점에서 끝나는 경로를 사이클(Cycle)이라고 함
  - 1 - 3 - 5 - 1

그래프 표현
- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬 (Adjacent matrix)
  - |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장한다.
- 인접 리스트 (Adjacent List)
  - 각 정점마다 해당 정점과 인접한 정점 정보를 저장
- 간선의 배열
  - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

인접 행렬: 두 정점을 연결하는 간선의 유무를 행렬로 표현
- |V| x |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
무향 그래프
- i번째 행의 합 = i번째 열의 합 = Vi의 차수

![alt text](<images/09_15/스크린샷 2025-09-15 141448.png>)

유향 그래프
- 행 i의 합 = Vi의 진출 차수
- 열 i의 합 = Vi의 진입 차수

![alt text](<images/09_15/스크린샷 2025-09-15 141552.png>)

인접 행렬의 단점
- 정점 수에 비해 간선 수가 적은 경우 공간 낭비가 심함

![alt text](<images/09_15/스크린샷 2025-09-15 141627.png>)

인접 리스트
- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장

![alt text](<images/09_15/스크린샷 2025-09-15 141731.png>)

무향 그래프의 인접 리스트

![alt text](<images/09_15/스크린샷 2025-09-15 141759.png>)

## DFS (Depth First Search, 깊이 우선 탐색)

DFS 알고리즘 - 재귀
- 모든 정점을 중복없이 빠짐없이 방문하는 경우
- G: 탐색할 그래프
- v: 방문하는 정점

![alt text](<images/09_15/스크린샷 2025-09-15 143026.png>)

DFS 알고리즘 - 반복

![alt text](<images/09_15/스크린샷 2025-09-15 143115.png>)

DFS 예

![alt text](<images/09_15/스크린샷 2025-09-15 143350.png>)

중복검사가 필요없는 DFS
- 스택에 push된 정점을 visited에 표시함

![alt text](<images/09_15/스크린샷 2025-09-15 143449.png>)

## BFS (Breadth First Search, 너비 우선 탐색)

BFS는 예제 그래프를 붙여진 번호 순서로 탐색함

![alt text](<images/09_15/스크린샷 2025-09-15 144031.png>)

입력 파라미터: 그래프 G와 탐색 시작점 v

![alt text](<images/09_15/스크린샷 2025-09-15 144200.png>)

BFS 예

![alt text](<images/09_15/스크린샷 2025-09-15 144235.png>)

## Union-Find (Disjoint set)

서로 소 집합(Disjoint-sets)
- 서로 공통 원소가 없는 집합
- 교집합이 없는 집합들 이다.

대표자(representative)
- 각 집합을 대표하는 하나의 원소를 말한다.

상호 베타 집합
- 확률, 논리, 집합론에서 동시에 일어날 수 없는 경우, 공통이 없는 경우를 말한다.
- 집합론에서는 서로 소와 같은 뜻으로 사용된다.

표현 방법
- 연결리스트로 표현할 수 있다.
- 트리를 이용해 표현할 수 있다.

서로 소 집합 연산
Make-Set(x)
- x를 원소로 가진 집합을 만든다.
Find-Set(x)
- x가 속한 집합의 대표 원소를 반환한다.
Union(x, y)
- y가 속한 집합과 x가 속한 집합의 합집합을 만든다.
- x가 합집합의 대표원소가 된다.

상호배타 집합 예
- Make-Set(x)
- Make-Set(y)
- Make-Set(a)
- Make-Set(b)
- Union(x, y)
- Union(a, b)
- Find-Set(y) -> x
- Find-Set(b) -> a
- Union(x, a)

![alt text](<images/09_15/스크린샷 2025-09-15 151331.png>)

상호 배타 집합 표현 - 연결리스트
- 같은 집합의 원소들은 하나의 연결리스트로 관리
- 연결리스트의 맨 앞의 원소가 집합의 대표 원소
- 각 원소는 집합의 대표원소를 가리키는 링크를 가짐

![alt text](<images/09_15/스크린샷 2025-09-15 151417.png>)

연결 리스트 연산 예
- Find-Set(e) return a
- Find-Set(f) return b
- Union(a, b)

![alt text](<images/09_15/스크린샷 2025-09-15 151458.png>)

상호 배타 집합 표현 - 트리
- 하나의 집합 (a disjoint set)을 하나의 트리로 표현함
- 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 됨

![alt text](<images/09_15/스크린샷 2025-09-15 151536.png>)

트리 연산 예
- Make-Set(a) ~ Make-Set(f)

![alt text](<images/09_15/스크린샷 2025-09-15 151627.png>)

- Union(c, d), Union(e, f)

![alt text](<images/09_15/스크린샷 2025-09-15 151637.png>)

- Union(d, f)
- Find-Set(d) return c
- Find-Set(e) return c

![alt text](<images/09_15/스크린샷 2025-09-15 151747.png>)

상호배타 집합을 표현한 트리의 배열을 이용한 저장

![alt text](<images/09_15/스크린샷 2025-09-15 152241.png>)

상호 배타 집합에 대한 연산
- Make-Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
```
Make-Set(x)
  p[x] <- x
```
- Find_Set(x): x를 포함하는 집합을 찾는 연산
```
Find-Set(x)
  IF x == p[x] : RETURN x
  ELSE         : RETURN Find_Set(p[x])
```
- Union(x, y): x와 y를 포함하는 두 집합을 통합하는 연산
```
Union(x, y)
  p[Find-Set(y)] <- Find-Set(x)
```
- Find_Set(x): x를 포함하는 집합을 찾는 연산 (반복)
```
Find-Set(x)
  While x != p[x]
    x = p[x]
  return x
```

- Make-Set(1)~(6)
- Union(1, 3)
- Union(2, 3)
- Union(5, 6)
- 여기 까지 연산 후 P 배열

![alt text](<images/09_15/스크린샷 2025-09-15 113238.png>)

- Find_Set(6)
  - 5가 반환

상호 배타 집합에 대한 연산 문제점
- 편향 트리가 되는 경우 Find_Set()에 시간이 오래 걸림
- Find_set()에서 찾아진 대표 원소로 각 원소의 대표우너소를 바꾸면 경로가 단축됨

![alt text](<images/09_15/스크린샷 2025-09-15 113445.png>)

연산의 효율을 높이는 방법
- Rank를 이용하 Union
  1. 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크(Rank)라는 이름으로 저장한다.
  2. 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다.

![alt text](<images/09_15/스크린샷 2025-09-15 113559.png>)

랭크를 이용한 Union에서 랭크가 증가하는 예

![alt text](<images/09_15/스크린샷 2025-09-15 113625.png>)

연산의 효율을 높이는 방법

Path compression
- Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꿔준다.

![alt text](<images/09_15/스크린샷 2025-09-15 113745.png>)

Make_Set() 연산
- Make_Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산

Find_Set 연산
- Find_Set(x): x를 포함하는 집합을 찾는 오퍼레시연
- Find_set 연산은 특정 노드에서 루트까지의 경로를 찾아 가면서 노드의 부모 정보를 갱신한다.
- Union(x, y): x와 y를 포함하는 두 집합을 통합하는 오퍼레이션