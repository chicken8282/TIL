# 9/3

# 진법과 연산

## 진법

## 1비트와 바이트

- 1 bit: 0과 1을 표현하는 정보의 단위
- 1 Byte: 8-bit를 묶어 1Byte라고 함 (메모리 주소가 부여되는 단위)

### 비트 연산

- 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함

- 비트 연산 챕터의 목적
  - 사람이 사용하는 사칙연산이 아닌 컴퓨터가 사용하는 연산인 "비트 연산"을 이해해봅니다.
  - 더 나아가, 프로그래밍에서 비트연산을 활용한 코딩 방법을 익혀봅니다.

### AND와 OR 비트연산자 이해하기

- a AND b: a, b 둘다 1일 때만 결과가 1, 그 외에는 0
- a OR b: a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0

### 파이썬 구현

- 7 & 5 -> 이진수로 표현하면 0b111 & 0b101

### 파이썬에서 2진수, 16진수, 10진수 변환하여 출력하기

- 2진수는 숫자 0과 소문자 b -> 0b를 접두사로 붙여 표현한다.
- 16진수는 숫자 0과 소문자 x -> 0x를 접두사로 붙여 표현한다.

```python
print(bin(10))
print(hex(10))
```

### XOR 와 NOT 연산자

- ^: XOR 연산자, 둘 다 1이거나 0인 경우는 0이다.
- !: NOT 연산자, 1이면 0, 0이면 1이다.

- 어떤 값이던 특정 수로 2 회 XOR를 하면 원래 수로 돌아옴
  - 7070 ^ 1004 = 6258
  - 6258 ^ 1004 = 7070

### 비트연산자

- LEFT Shift <<: 특정 수 만큼 비트를 왼쪽으로 밀어냄
- Right Shift >>: 특정 수 만큼 비트를 오른쪽으로 밀어냄 (우측 비트들이 제거됨)

```python
print(bin(0b1101 << 2)) # 0b110100
print(bin(0b1101 >> 2)) # 0b11
```

### 비트 연산 응용

1 << n

- 2^n의 값을 갖는다.
- 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.

i & (1 << n)

- i의 n번째 비트가 1인지 아닌지를 확인할 수 있다.
- 1101 & (1 << 2)
  - 1101에서 2번 bit가 1인지 확인 가능하다. (결과값 = 0100)
  - 결과값이 0보다 크면 n 번째 비트는 1임이 확정된다.

### 음수 표현 방법

- 컴퓨터는 음수를 "2의 보수"로 관리함 맨 앞자리 bit (MSB)는 음수 or 양수를 구분하는 비트
- 컴퓨터가 2의 보수를 사용하여 음수를 관리하는 이유
- 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용한다.

```python
def bit_print(i):
  output = ''
  for j in range(7, -1, -1):
    output += '1' if i & (1 << j) else '0'
  print(output)

for i in range(-5, 6):
  print(f'{i} = ', end='')
  bit_print(i)
```

![alt text](<images/스크린샷 2025-09-03 112732.png>)

### 2의 보수 예시

**10001의 2의 보수**\
-> 수를 모두 뒤집고 +1을 더한다.\
-> 01110 + 1 = 01111

**1111000의 2의 보수**\
-> 수를 뒤집으면 0000111이고 + 1을 더한다.\
-> 0000111 + 1 = 0001000

- 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 원래의 값으로 돌아옴

- 10001의 2의 보수
-> 수를 모두 뒤집고 +1을 더한다\
-> 01110 + 1 = 01111

- 01111의 2의 보수
-> 10000 + 1 = 10001

### -5를 2의 보수로 표현하는 방법 (가정: 수를 8-bit로 저장하는 경우)

1. 수 5를 2진수로 나타내면 0000 0101 (7-bit)
2. -5는 음수이기에 MSB는 1
3. 나머지 7-bit에 대해, 수를 뒤집고 1을 더함 (2의 보수)
4. 수 5를 뒤집으면 111 1010 이며, 1을 더하면 111 1011이 됨
5. 따라서 1111 1011

### bitwise NOT(complement) 연산자

- ~연산자: 모든 비트를 반전시킴
- 만약 8-bit 일 때 ~(0001 1111) 이라면 값은 1110 0000이 됨

- 파이썬에서는 ~4를 수행하면 -5가 출력됨
  1. 4는 0b0100 (MSB: 양수이므로 0)
  2. NOT 연산자로 인해 뒤집으면 1011이 된다.
  3. MSB는 1이 되었고 (음수), 나머지 bit는 011이다.
  4. 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101 이므로 5가 된다.
  5. 따라서 -5가 된다.

## 실수

파이썬에서 실수 출력 방법

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다.')
print(f'변수 값은 {t2} 입니다.') # 변수 값은 3.141592 입니다.
```

### 소수점 출력 방법

- {t2:2f}: t2 값을 소수점 셋째자리에서 반올림하여 표현

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다.')
print(f'변수 값은 {t2:.2f} 입니다.') # 변수 값은 3.14 입니다.
```

### 파이썬에서의 실수 표현 범위

- 파이썬에서는 64비트 부동소수점으로 실수를 표현함
  - 15 ~ 17자리 정밀도와 +-1.8e308 범위를 갖는다.
- 최대로 표현할 수 있는 값은 약 1.8 * 10^308이고 이 이상은 inf로 표현
- 최소로 표현할 수 있는(0에 가장 가까운) 값은 약 5.0 * 10^-324이며, 이 이하는 0으로 표현

### 컴퓨터는 실수를 내부적으로 근사적으로 관리

- 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

```python
print(0.1 + 0.1 + 0.1 == 0.3) # False
```

### 소수점이 있는 10진수를 2진수로 변환 예시

- 0.75 = 2^-1 + 2^-2 = 0.11(2)

- 0.40625 = 2^-2 + 2^-3 + 2^-5 = 0.01101(2)

![alt text](<images/스크린샷 2025-09-03 114634.png>)

소수점을 포함한 2진 실수를 10진수로 변환하는 예시

![alt text](<images/스크린샷 2025-09-03 114729.png>)

### 실수를 표현

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floation-point) 표기법을 사용한다. 이 표기법은 IEEE 754 라는 컴퓨터에서 부동소수점을 표기하는 국제표준이다.
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
- 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑 수의 지수승으로 표현
`1001.0011 -> 1.0010011 * 2^3`

### 실수를 저장하기 위한 형식 (IEEE 754, 32bits - Single Precision 표기법 기준)

- 32-bit 구조\
![alt text](<images/스크린샷 2025-09-03 120318.png>)
- 부호 1비트: 0이면 양수, 1이면 음수
- 지수부(exponent): 부동소수점의 크기 + bias값
- 가수부(mantissa): 실질적 수
