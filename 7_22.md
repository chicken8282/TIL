# 7/22

# list
여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형
## 표현
- 대괄호 [] 안에 값들을 쉼표(,)로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는등 자유롭게 변경할 수 있음
```python
my_list_1 = []
my_list_2 = [1, 'a', 3 ,'b', 5]
my_list_3 = [1, 2, 3, ['Python', 'world', '!!!']]
```

## 리스트의 시퀀스 특징
- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

## 중첩 리스트
다른 리스트를 값으로 가진 리스트

### 접근하기
- 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음

1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
    - `my_list[4] -> ['hello', 'world', '!!!']`
2. 선택한 안쪽 리스트에 다시 한번 인덱스를 사용
    - `my_list[4][-1] -> '!!!'`

## 리스트의 가변성
여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형\
**-> 추가, 삭제, 변경 가능**

# tuple
여러 개의 값을 순서대로 저장하는 **변경 불가능한 시퀀스 자료형**

## 튜플 표현
- 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음
```python
my_tuple_1 = ()
my_tuple_2 = (1,)
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```
-  소괄호 없이도 만들 수 있다.
- 단일 요소 튜플을 만들 때 반드시 Trailing comma (후행 쉼표)를 사용해야 합니다.
## 시퀀스 특징
- 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음
## 튜플 변경 시도하기
- 한번 생성된 튜플을 그 내용을 절대 수정, 추가, 삭제할 수 없음

### 어디 쓰일까?
- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값 교환, 함수 다중 반환 값 등
```python
# 다중 할당
x, y = 10, 20
# 실제 내부 동작
(x, y) = (10, 20)

# 값 교환
x, y = 1, 2
x, y = y, x
# 실제 내부 동작
temp = (y, x)
x, y = temp
print(x, y) # 2 1
```

# range
- 연속된 정수 시퀀스를 생성하는, 변경 불가능한(immutable) 자료형
    - 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용하다.
    - 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용

## range 기본 구문
- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있다.\
`range(start, stop, step)`
## 매개변수별 특징
- range(stop)
    - 매개변수가 아니면 stop으로 인식
    - start는 0이, step은 1이 기본값으로 자동 설정
    - range(5) = 0, 1, 2, 3, 4
- range(start, stop)
    - 매개변수가 두 개면 start와 stop으로 인식
    - step은 1이 기본값으로 자동 설정
    - range(2, 5) -> 2, 3, 4
- range(start, stop, step)
    - 모든 매개변수를 직접 지정
    - range(2, 10, 2) -> 2, 4, 6, 8
    
```python
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_1)  # range(0, 5)
print(my_range_2)  # range(1, 10)
print(my_range_3)  # range(5, 0, -1)

# 리스트로 형 변환 시 데이터 확인 가능
print(list(my_range_1))  # [0, 1, 2, 3, 4]
print(list(my_range_2))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3))  # [5, 4, 3, 2, 1]
```
## 규칙
1. 값의 범위 규칙
- stop 값은 생성되는 시퀀스에 절대 포함되지 않음
- range(1, 5)는 1부터 5 '전'까지의 숫자를 의미하므로 1, 2, 3, 4가 생성

2. 증가/감소 값(step) 규칙
- steap 값은 숫자 시퀀스의 간격과 방향을 결정

    1. step이 양수일 때
        - 숫자가 start부터 stop을 향해 증가
    2. step이 음수일 때
    - 숫자가 start부터 stop을 향해 감소
    - 이 경우, start 값은 stop 값보다 반드시 커야 함

# dict
- **key - value 쌍**으로 이루어진 **순서와 중복**이 없는 **변경 가능**한 자료형

## 표현
- 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- Key(키)
    - 값을 식별하기 위한 고유한 '이름표'(중복불가)
- Value(값)
    - 키에 해당하는 실제 데이터
- 각 값에는 순서가 없음

```python
my_dict_1 = {}
my_dict_2 = {'key': 'value'}
my_dict_3 = {'apple': 12, 'list': [1, 2, 3]}

print(my_dict_1)  # {}
print(my_dict_2)  # {'key': 'value'}
print(my_dict_3)  # {'apple': 12, 'list': [1, 2, 3]}
```

- 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서는 출력 시 그대로 유지해주긴 함
- 하지만 여전히 딕셔너리의 핵심은 순서가 없는 자료형이라는 점과 key를 통한 접근이라는 점 기억하자

## 규칙
- key의 규칙
    - 고유해야 함
        - key는 중복될 수 없음
    - 변경 불가능한 자료형만 사용 가능
        - 가능: str, int, float, tuple
        - 불가능: list, dict

- value의 규칙
    - 어떤 자료형이든 자유롭게 사용할 수 있음

## 접근 방법
- key를 사용하여 해당 Value를 꺼내 올 수 있음
- key에 접근 시 대괄호 [] 사용

## 값 추가 및 변경
```python
# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```
# set
순서와 중복이 없는 변경 가능한 자료형

## 표현
- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능

```python
my_set_1 = set()
my_set_2 = {1, 2, 3}
my_set_3 = {1, 1, 1}

print(my_set_1)  # set()
print(my_set_2)  # {1, 2, 3}
print(my_set_3)  # {1}
```

## 핵심 특징
1. 중복을 허용하지 않음
    - 똑같은 값은 단 하나만 존재할 수 있음
2. 순서가 없음
    - 인덱싱(set[0])이나 슬라이싱(set[0:2])을 사용할 수 없음

## 집합 연산
- 세트는 수학의 '집합' 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적

```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```
# None
파이썬에서 '값이 없음'을 표현하는 특별한 데이터 타입

- 값이 '존재하지 않음' 또는 '아직 정해지지 않음' 이라는 상태를 나타내기 위해 사용됨

# Boolean
참(True)과 거짓(False)단 두 가지 값만 가지는 데이터 타입

- 비교 / 논리 연산의 평가 결과로 사용됨

# Collection
여러 개의 값을 하나로 묶어 관리하는 자료형들을 통치하는 말

- str, list, tuple, range, set, dict 데이터 타입이 모두 Colletion에 분류됨

## 불변 vs 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변'두 그룹으로 나뉨

# 형변환
한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 예를 들어, 문자열"100"을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 등 데이터의 '형태'를 필요에 따라 바꾸는 것

## 암시적 형변환
파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
- 암시적 형변환은 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙

### 예시
- 정수와 실수의 연산에서 정수가 실수로 변환됨
- Boolean과 Numertic Type에서만 가능

## 명시적 형변환
개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
- 명시적 형변환은 서로 다른 타입의 데이터를 '호환'되도록 맞추는 과정

# 연산자

## 산술 연산자
수학적 계산을 위해 사용되는 연산자

## 복합 연산자
연산과 할당이 함께 이뤄짐\
`+=` `-=` `*=` `/=` `//=` `%=` `**=` 등등

## 비교 연산자
두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환\
`<`, `<=`, `==`, `!=`, `is`, `is not` 등등

### == 연산자
- 값(데이터)이 같은지를 비교
- 동등성
- 1 == True의 경우 파이썬이 내부적으로 Truef를 1로 간주할 수 있으므로 True결과가 나옴

### is 연산자
- 객체 자체가 같은지를 비교
- 식별성
-  두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용

#### is 연산자는 언제 사용하는가?
- 주로 싱글턴 객체를 비교 할 때 사용함

#### 싱글턴 객체
- 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체
- 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
- 파이썬의 대표적인 싱글턴 객체: None, True, False

### 정리
- is는 주로 싱글턴 객체에 대한 비교 시 사용
- 값 비교에는 `==`을 사용하고, 객체 비교에는 `is`를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값) 을 판단해야 할 때 is를 쓰면 의도치 않은 결과가 나올 수 있으며, 이는 파이썬 내부적인 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문

## 논리 연산자
- 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용(and, or, not이 대표적)

### 단축 평가
논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

#### 단축 평가를 하는 이유
- 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함

## 멤버십 연산자
특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

`in`: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인\
`not in`: 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인

## 시퀀스형 연산자
- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- `+`는 시퀀스를 연결하는 기능을, `*`는 시퀀스를 반복하는 기능을 함

# 후행 쉼표(Trailing Comma)
컬렉션의 마지막 요소 뒤에 붙는 쉼표

## 기본 규칙
- 각 요소를 별도의 줄에 작성
- 마지막 요소 뒤에 trailing comma 추가
- 닫는 괄호는 새로운 줄에 배치

