# 9/11

# 백트래킹

## 백트래킹 응용

백트래킹(Backtracking) 개념

- 여러 가지 선택지 (옵션)들이 존재하는 상황에서 한 가지를 선택함
- 선택이 이루어지면 새로운 선택지들의 집합이 생성됨
- 이런 선택을 반복하면서 최종 상태에 도달함
  - 올바른 선택을 계속하면 목표 상태(goal state)에 도달한다.

문제 제시: N-Queen 문제
![alt text](<09_11/스크린샷 2025-09-11 091736.png>)

당첨 리프 노드 찾기

- 루트에서 갈 수 있는 노드를 선택함
- 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작
- 더 이상의 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택함
- 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답이 없음

백트래킹과 깊이 우선 탐색과의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로르 따라가지 않음으로써 시도의 횟수를 줄임
- 이를 Pruning(가지치키)라고 한다.
- 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많은 경우, 즉,N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제가 됨
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우에는 여전히 지수 함수 시간 (Exponetial Time)을 요하므로 처리 불가능함

4-Queens 문제로 축소해서 생각해 보기

- 같은 행에 위치할 수 없음
- 모든 경우의 수: 4 x 4 x 4 x 4 = 256

![alt text](<09_11/스크린샷 2025-09-11 094438.png>)

백트래킹 개념

- 루트 노드에서 리프(leaf) 노드까지의 경로는 해답후보(candidate solution)가 되는데, 깊이 우선 검색을 하여 그 해답후보 중에서 해답을 찾을 수 있음
- 그러나 이 방법을 사용하면 해답이 될 가능성이 전혀 없는 노드의 후손 노드(descendant)들도 모두 검색해야 하므로 비효율적

# 트리

## 트리 개요

트리(Tree)

- 트리는 싸이클이 없는 무향 연결 그래프임
  - 두 노드 (or 정점) 사이에는 유일한 경로가 존재한다.
  - 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.
  - 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.

비선형 구조

- 원소들 간에 1:n 관계를 가지는 자료구조 이다
- 원소들 간에 계층관계를 가지는 계층형 자료구조 이다.

## 이진트리

- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
  - 왼쪽 자식 노드 (left child node)
  - 오른쪽 자식 노드 (right child node)

이진 트리의 특성

- 레벨 i에서의 노드가 최대 개수는 (2^i) - 1개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 최대 개수는 ((2^h+1) - 1)개

포화 이진 트리 (Full Binary Tree)

- 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

완전 이진 트리 (Complete Binary Tree)

- 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리

편향 이진 트리 (Skewed Binary Tree)

- 높이가 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리

순회
트리의 각 노드를 중복되지 않게 전부 방문(visit)하는 것

3가지의 기본적인 순회 방법

- 전위순회 (preorder traversal): VLR
- 중위순회 (inorder traversal): LVR
- 후위순회 (pastorder traversal): LRV
