# 8/06

# 2차원 배열

2차원 배열의 선언
- 1차원 List를 묶어놓은 List
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
- 2차원 List의 선언: 세로길이 (행의 개수), 가로길이 (열의 개수)를 필요로 함
- python 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함

```python
'''
3
1 2 3
4 5 6
7 8 9
'''

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

'''
123
456
789
'''

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
```

배열 순회
- n x m 배열의 n * m 개의 모든 원소를 빠짐없이 조사하는 방법

```python
# i 행의 좌표
# j 열의 좌표
for i in range(n):
  for j in range(m):
    f(array[i][j]) # 필요한 연산 수행
```

N X M 배열의 크기와 저장된 값이 주어질 때 합을 구하는 방법

```python
N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

s = 0

for i in range(N):
  for j in range(N):
    s += arr[i][j]
```

열 우선 순회
```python
# i 행의 좌표
# j 열의 좌표

for j in range(m):
  for i in range(n):
    f(array[i][j]) # 필요한 연산 수행
```

지그재그 순회
```python
# i 행의 좌표
# j 열의 좌표

for i in range(n):
  for j in range(m):
    f(array[i][j + (m - 1 - 2*j) * (i % 2)])
```

## 델타

델타를 활용한 2차원 배열 탐색
- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
- 인덱스 (i, j)인 칸의 상하좌우 칸 (ni, nj)

```python
di[] = [0, 1, 0, -1]
dj[] = [1, 0, -1, 0]

for k in range(4):
  ni = i + di[k]
  nj = i + dj[k]
```

- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
```python
arr[0...N-1][0...N-1] # N x N 배열
di[] = [0, 1, 0, +1]
dj[] = [1, 0, -1, 0]
for i in range(N-1):
  for j in range(N-1):
    for d in range(4):
      ni = i + di[d]
      nj = j + dj[d]
      if 0 <= ni < N and 0 <= nj < N: # 유효한 인덱스면
        f(arr[ni][nj])
```

- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법(2)
```python
for i in range(N):
  for j in range(N):
    for di, dj in [[0, 1],[1, 0],[0, -1],[-1, 0]]:
      ni, nj = i + di, j + dj
```

델타 응용
- N x N 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최대값(k = 2)
```python
max_v = 0
for i in range(N):
  for j in range(N):
    s = arr[i][j]
    for di, dj in [[0, 1],[1, 0],[0, -1],[-1, 0]]: # 각 방향
      for c in range(1, k + 1):               # 거리별
        ni, nj = i + di * c, j + dj * c
        if 0 <= ni < N and 0 <= nj < N:
          s += arr[ni][nj]

    if max_v < s:
      max_v = s
```

전치 행렬
```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 3 * 3 행렬

for i in range(3):
  for j in range(3):    # for j in range(i):인 경우
    if i < j:               # if문 필요 없음
      arr[i][j], arr[j][i] = arr[j][i], arr[i][j]