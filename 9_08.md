# 9/8

# 조합적 문제

## 부분 집합(Power set)

어떤 집합의 공집합과 자기자신을 포함한 모든 부분

집합에 포함된 원소들을 선택하는 것

부분 집합 예시

- 아래의 표는 집합 {A,B,C}로 만들 수 있는 부분 집합의 예시이다.
- 부분 집합에는 아무것도 선택하지 않은 경우도 포함된다. (공집합)\
![alt text](<images/09_08/스크린샷 2025-09-08 090743.png>)

집합에서 부분 집합을 찾아내는 구현 방법

**1. 완전탐색**

- 재귀호출을 이용한 완전탐색으로, 부분 집합을 구할 수 있다.
- 실전 보다는 완전 탐색 학습용으로 추천하는 방법

**2. Binary Counting**

- 2진수 & 비트연산을 이용하여, 부분 집합을 구할 수 있다.
- 모든 부분 집합이 필요할 때 사용하는 추천 방법이다.
  
**완전탐색으로 부분 집합 구하기**

- 민철이에게는 세 명의 친구가 있다. {MIN, CO, TIM}
- 함께 영화관에 갈 수 있는 멤버를 구성하고자 한다.
- 모든 경우의 수를 출력해보자.

**완전 탐색을 이용해 구현**

- O, X로 집합에 포함 시킬지 말지 결정
![alt text](<images/09_08/스크린샷 2025-09-08 091033.png>)

코드 구현

- Branch: 2개
- Level: 3개

```python
arr ['O','X']
path = []
name = ['MIN', 'CO', 'TIM']

def run(lev):
  if lev == 3:
    print(path)
    return

    for i in range(2):
      path.append(arr[i])
      run(lev + 1)
      path.pop()

run(0)
```

![alt text](<images/09_08/스크린샷 2025-09-08 091251.png>)

바이너리 카운팅(Binary Counting)

- 원소 수에 해당하는 N개의 비트열을 이용해 부분집합을 표시
- 001 이면 부분 집합 {A}를 나타냄
  - 0번 비트가 1이므로 첫 원소인 A만 포함된 부분집합을 나타낸다.
- 110 이면 부분 집합 {B, C}를 나타냄
  - 1번, 2번 비트가 1이므로, 두번째와 세번째 원소인 B, C가 포함된 부분집합을 나타낸다.

부분 집합의 총 개수

- 만들 수 있는 집합의 총 개수는 2^n이며 n = 3 이기에, 총 8개의 부분 집합 존재
- 2^n은 1 << n 공식을 이용하여 빠르게 구할 수 있음

부분 집합 {B, C}를 만드는 과정

- 6(0b110)에서 비트 연산을 이용하여 마지막 한 자리가 1인지 0인지 검사

```python
name = ['MIN', 'CO', 'TIM']


def recur(cnt, subset):
    if cnt == 3:
        print(*subset)
        return

    # 부분집합에 포함 시키는 경우
    recur(cnt + 1, subset + [name[cnt]])
    # 포함 시키지 않는 경우
    recur(cnt + 1, subset)


recur(0, [])
```

- 검사한 한 자리를 제거  (tar >>= 1)

![alt text](<images/09_08/스크린샷 2025-09-08 093807.png>)

## 조합(comination)

서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

```python
arr = [1, 2, 3, 4]

# i: 0~2^n == i번째 부분집합
for i in range(1 << len(arr)):
    for idx in range(len(arr)):
        if i & (1 << idx):
            print(arr[idx], end=" ")
    print()

# 검사하고자 하는 비트를 오른쪽으로 하나씩 shift 하면서 체크하는 코드
def get_sub(tar):
    print(f'target = {tar}', end=' / ')
    for i in range(len(arr)):
        # 0x1 로 표기한 이유 (사실 1, 0b1, 0b0001, True 다 된다)
        # - 비트 연산임을 명시하는 권장 방법
        if tar & 0x1:  # 가장 우측 비트를 체크
            print(arr[i], end=' ')
        tar >>= 1


for target in range(1 << len(arr)):
    get_sub(target)
    print()
```

순열과 조합 차이
![alt text](<images/09_08/스크린샷 2025-09-08 101835.png>)

# 탐욕 알고리즘

## Greedy

결정이 필요할 때, 현재 기준으로 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘

대표적인 문제 해결 기법

1. 완전 탐색(Brute-Force)

- 답이 될 수 있는 모든 경우를 시도해보는 알고리즘

2. Greedy

- 결정이 필요할 때 가장 좋아 보이는 선택지로 결정하는 알고리즘

3. DP

- 현재에서 가장 좋아 보이는 것을 선택하는 것이 아닌, 과거의 데이터를 이용하여 현재의 데이터를 만들어내는 문제해결기법

4. 분할 정복 (차후 학습 예정)

- 큰 문제를 작은 문제로 나누어 해결하는 문제해결기법

그리디로 문제 푸는 법

1. 탐욕적 선택 조건 (Greedy Choice Property)

- 각 단계의 최적해 선택이 이 후 단계 선택에 영향을 주지 않는다.
- 즉, 각 단계 규칙이 변경되면 안된다.

동전 교환 문제
![alt text](<images/09_08/스크린샷 2025-09-08 102639.png>)

- 첫 번째 단계: 가장 큰 동전 (500원) 가능한 만큼 주자
- 두 번째 단계: 가장 큰 동전 (100원) 가능한 만큼 주자\
....\
--> 각 단계를 진행하면서 규칙이 유지\

2. 최적 부분 구조 (Optimal Substructure)

- 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이 되어야 함\
--> 증명을 통해 해결

- 동전 문제 예시
  - [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나온다.
  - [간접 증명]
    - 최적해보다 더 작은 동적으로 표현 가능하다. (가정)\
    -> N원을 더 작은 값의 동전으로 더 작은 수로 할 수 있다.\
      ==> 동전이 배수로 있기 떄문에 안됨\
      ==> 더 적은 값으로 나누면 무조건 더 큰수가 나옴\
      -> 모순 발생\
      ==> 원래 명제가 참

3. 반례가 없는가?

화장실 문제
![alt text](<images/09_08/스크린샷 2025-09-08 104428.png>)

- 대기시간 오름차순으로 정렬한다.

## Knapsack 문제

도둑이 보물들이 있는 창고에 침입하였다.
도둑은 최대 30kg까지 짐을 담아갈 수 있다.
물건은 하나 씩만 존재한다.

물건의 개수(N) 그리고 물건 별 무게(W)와 가격(P)이 주어질 때,
어떤 물건을 담아야 도둑이 최대 이득을 볼 수 있을지 구하시오.

- 물건은 하나 씩만 존재한다.

## 활동 선택 문제

회의실이 하나인 회사가 있다.
여러 팀들이 원하는 회의실 예약 시간이 주어질 때,
가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?

- 희망 회의 개수, 시작 시간, 종료 시간을 입력 받는다.

**문제 해결 방법**\
회의 종료시간이 가장 빠른 회의를 먼저 선택한다.

- (2, 4), (4, 6),(7, 8) 또는 (8, 9)회의를 선택하면 3개의 회의를 배정할 수 있다.

# 총정리

1. 순열 vs 부분 집합 vs 조합

- 각 문제들의 접근법

2. 그리디

- 그리디 규칙을 잘 찾고, 그리디 조건 검증
- 많은 문제를 풀어보자!
